---
layout:     post   				    # 使用的布局（不需要改）
title:      排序算法总结	# 标题 
subtitle:   经典排序算法时间、空间复杂度、思想、实现等	#副标题
date:       2019-07-09 				# 时间
update_date: 2020-11-21  			# 更新时间
author:     pfan8 						# 作者
header-img: img/post-bg-dsa.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 算法
    - 排序
    - 总结
---

## 一、时间复杂度总结
![](https://miro.medium.com/max/745/1*ipkeWQ_Lb0lbkhB8rigxTA.png)

## 1.1 排序算法划分

排序算法的划分可以从几个不同的维度进行划分

### 时间复杂度

1. 平方阶 $$O(n^2)$$： 各类简单排序：直接插入、直接选择和冒泡排序。
2. 线性对数阶 $$O(nlog(n^2))$$： 快速排序、堆排序、希尔排序和归并排序
3. 线性阶 $$O(n)$$： 基数排序，此外还有桶、箱排序。

### 空间维度

如果要分析排序算法占用多少内存，是否需要外存就能完成排序等，可以分为以下几种排序

+ 内部排序：若整个排序过程不需要访问外存便能完成，则称此类排序问题为内部排序。
+ 外部排序：若参加排序的记录数量很大，整个序列的排序过程不可能在内存中完成，则称此类排序问题为外部排序。
+ 就地排序：若排序算法所需的辅助空间并不依赖于问题的规模n，即辅助空间为O（1），称为就地排序。

与其说用内部排序和外部排序来划分不同的排序算法，不如说内外排序是不同的算法策略

+ 内部排序在加载数组进内存后，使用一种排序算法进行排序即可完成
+ 而外部排序通常采用**排序-归并**，将指定大小的数据（如100M）加载进内存，使用内排中的某种排序算法（如快速排序、堆排序、归并排序等方法）在内存中完成排序，再讲排序完成的数据写入磁盘。不断重复上述过程，完成所有数据排序之后，对外存中排序好的数据进行归并处理。关于外部排序的详细描述，可以查看[wiki](https://zh.wikipedia.org/wiki/%E5%A4%96%E6%8E%92%E5%BA%8F)

而就地排序则是针对排序算法是否需要使用额外辅助空间，常见排序算法的划分如下：
1. 就地排序：冒泡排序、选择排序、插入排序、希尔排序、快速排序（如果不考虑递归函数空间的话）
2. 非就地排序：堆排序、归并排序、桶排序、基数排序

### 元素相对位置

**稳定排序**：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序后，这些记录的相对次序保持不变，即在原序列中 ri=rj， ri 在 rj 之前，而在排序后的序列中，ri 仍在 rj 之前，则称这种排序算法是稳定的；否则称为不稳定的。

1. 稳定：冒泡排序、插入排序、归并排序和基数排序。

2. 非稳定：选择排序、快速排序、希尔排序、堆排序。

## 二、经典排序算法

### 2.1 冒泡排序

英文名称是 bubble sort

已知一组无序数据a[0]、a[1]、……a[n-1]，需将其用冒泡排序按升序排列。

首先比较a[0]与a[1]的值，若a[0]大于a[1]则交换两者的值，否则不变。再比较a[1]与a[2]的值，若a[1]大于a[2]，则交换两者的值，否则不变。以此类推。。。最后比较a[n-2]与a[n-1]的值。这样处理一轮后，a[n-1]的值一定是这组数据中最大的。

再对a[0]~a[n-2]以相同方法处理一轮，则a[n-2]的值一定是a[0]~a[n-2]中最大的。以此类推。。。

这样共处理 n-1 轮后a[0]、a[1]、……a[n-1]就以升序排列了。

```
Example
待排序列    3    2    5    9    2

第一轮

第1次比较  2    3   5    9    2

第2次比较  2    3    5    9    2

第3次比较  2    3    5    9    2

第4次比较  2    3    5    2  |  9

第二轮

第5次比较  2    3    5    2    9

第6次比较  2    3    5    2    9

第7次比较  2    3    2  |  5    9

第三轮

第8次比较  2    3    2    5    9

第9次比较  2    2  |  3    5    9

第四轮

第10次比较  2  |  2    3   5    9
```

以上分割线左侧为下一轮的待排序序列，右侧为已排序好的序列。

可以看到5个关键码组成的序列，经过4轮共计10次比较，比较次数是不变的，比较次数公式为：

$$n*(n-1)/2$$

**动画演示**

![](https://mmbiz.qpic.cn/mmbiz_gif/D67peceibeISwc3aGibUlvZ0XqVnbWtBRiaC1S2jpXRzXcZVn0aP6BYnkO2FJicNstxicHmf9wMIic5FV0I75ptv5jYA/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1)

**算法评价**

优点：如果你不是故意去交换相等的关键码的话，这个算法是绝对稳定的排序算法。

缺点：比较次数也就是所谓的时间复杂度 为$$O(n^2)$$，最好的情况和最坏的情况都是$$O(n^2)$$

从上面例子中，我们可以看到第一、二、三轮，2和3两个关键码重复比较了3次，很显然这不是令人满意的，那么如何解决这个问题呢？答案是快速排序

事实上，虽然冒泡排序是最基本的经典算法，但现实中基本都使用快速排序，基本没有使用冒泡排序的scene了

## 动画与解析
发现一个总结的很好的博客，这里直接给出[链接](https://mp.weixin.qq.com/s/vn3KiV-ez79FmbZ36SX9lg)，我就不重复造轮子了XD

## 更多
个人更多算法总结在[Github](https://github.com/pfan8/LeetCode)