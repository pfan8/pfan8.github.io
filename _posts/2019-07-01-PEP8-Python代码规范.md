---
layout:     post   				    # 使用的布局（不需要改）
title:      PEP-08 Python代码规范	# 标题 
subtitle:   PEP 8 -- Style Guide for Python Code		 #副标题
date:       2019-07-01 				# 时间
author:     pfan8 						# 作者
header-img: img/post-bg-pep.png	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - PEP
    - Python
    - 规范
---

为了让自己写的代码更加Pythonic，有必要细读[PEP8](<https://www.python.org/dev/peps/pep-0008/>)，关于PEP的介绍参考本人的[另一篇博客](https://pfan8.github.io/2019/07/01/PEP%E4%BB%8B%E7%BB%8D/)

下面为正文，中文翻译自官网，参考自[Python程序员分享的文章](<https://mp.weixin.qq.com/s/vnkHenVJRiRUzl6SK26biw>)，但有一些翻译我觉得不妥，做了改动~

## 介绍

本文档所提供的编码规范，适用于主要的Python发行版中组成标准库的Python代码。请参阅[PEP关于Python的C实现的C编码风格指南的描述](<https://www.python.org/dev/peps/pep-0007/>)。



本文档和PEP257（文档字符串规范）改编自Guido的《Python Style Guide》一文，用[Barry的风格指南](<https://barry.warsaw.us/software/STYLEGUIDE.txt>)做了一些补充。



这篇风格指南随着时间的推移而逐渐演变，随着语言本身的变化，过去的规则可能会被新规则替代。



许多项目都有自己的编码风格指南。如果有任何冲突，优先使用本篇指南（PEP-08）。

## 令人讨厌的小人物身上愚蠢的一致性

Guido的一个重要的观点是：代码读的次数比写的次数多得多。这里提供的指南旨在提高代码的可读性，并使各种不同的Python代码一致。正如PEP-20所说，“易读性非常重要”。



一篇风格指南需要保持一致的思想，与本风格指南一致很重要，项目中的一致性更重要，一个模块或功能中的一致性是重中之重。



然而，你需要知道何时会不一致——有时PEP-08就不适用了。怀疑时，作出你自己的最优决策。看看其他的例子，并决定什么是最好的。另外不要犹豫，尽管提问！



特别地：不要只为遵从这个PEP而打破向后兼容性！



其他一些不应该遵循PEP-08的情况：
1、当遵循PEP-08会降低代码的可读性，甚至对于那些习惯遵照这个PEP来阅读代码的人来说也是如此的时候。
2、与周围的代码保持一致也会破坏它（可能是历史原因）——虽然这也是收拾别人烂摊子的好机会（在真正的XP风格中）。
3、因为问题代码先于PEP-08，又没有其它的修改理由。
4、代码需要兼容老版本，其中包含PEP-08不建议使用的Python特性。

## 代码布局

### 缩进

每级缩进使用4个空格。



连续行应该对齐折叠元素，无论是垂直的Python的隐式行连接圆括号内的，中括号内的，大括号内的，还是使用[悬挂缩进]( "指的是除了第一行，其他行都缩进的Python代码风格。通常用于一个大括号的分行中")。使用悬挂缩进应注意以下几点：



第一行没有参数并且使用更多的缩进来区别它本身和接下来的其他行代码。

正确的（Yes）：

```python
# Aligned with opening delimiter.
foo = long_function_name(var_one, var_two,
                         var_three, var_four)

# Add 4 spaces (an extra level of indentation) to distinguish arguments from the rest.
def long_function_name(
        var_one, var_two, var_three,
        var_four):
    print(var_one)

# Hanging indents should add a level.
foo = long_function_name(
    var_one, var_two,
    var_three, var_four)
```

错误的（No）

```python
# Arguments on first line forbidden when not using vertical alignment.
foo = long_function_name(var_one, var_two,
    var_three, var_four)

# Further indentation required as indentation is not distinguishable.
def long_function_name(
    var_one, var_two, var_three,
    var_four):
    print(var_one)
```

对于悬挂缩进的代码，既定的4个空格是可以替换的

例如

```python
# Hanging indents *may* be indented to other than 4 spaces.
foo = long_function_name(
  var_one, var_two,
  var_three, var_four)
```

if语句条件块足够长时需要编写多行，值得注意的是两个字符组成的关键字（例如if），加上一个空格，加上开括号为多行条件的后续行创建一个4个空格的缩进。这可以给嵌入if内的缩进语句产生视觉冲突，这也自然被缩进4个空格。这个PEP没有明确如何（是否）进一步区分条件行和if语句内的嵌入行。这种情况下，可以接受的选项包括，但不仅限于：

```python
# No extra indentation.
if (this_is_one_thing and
    that_is_another_thing):
    do_something()

# Add a comment, which will provide some distinction in editors
# supporting syntax highlighting.
if (this_is_one_thing and
    that_is_another_thing):
    # Since both conditions are true, we can frobnicate.
    do_something()

# Add some extra indentation on the conditional continuation line.
if (this_is_one_thing
        and that_is_another_thing):
    do_something()
```

（其他[二元操作符](#换行应该在二元操作符的前面还是后面？)同样存在上述的讨论）

多行结构中的结束花括号/中括号/圆括号是最后一行的第一个非空白字符，如：

```python
my_list = [
    1, 2, 3,
    4, 5, 6,
    ]
result = some_function_that_takes_arguments(
    'a', 'b', 'c',
    'd', 'e', 'f',
    )
```

或者是最后一行的第一个字符，如：

```python
my_list = [
    1, 2, 3,
    4, 5, 6,
]
result = some_function_that_takes_arguments(
    'a', 'b', 'c',
    'd', 'e', 'f',
)
```

### 制表符(Tab)还是空格(Space)？

空格是缩进方法的首选。
制表符仅用于与已经用制表符做缩进的代码保持一致。
Python3不允许混用制表符和空格来缩进。
Python2代码混用制表符和空格缩进，将被转化为只使用空格。
调用Python2命令行解释器时使用-t选项，可对代码中非法混用制表符和空格发出警告。当使用-tt选项，警告将变成错误。这些选项是高度推荐的！

### 行的最大长度

限制所有行最多79个字符。

下垂的长块结构限制为更少的文本（文档字符串或注释），行的长度应该限制在72个字符。

限制编辑器窗口宽度使得并排打开多个文件成为可能，并且使用代码审查工具显示相邻列的两个版本工作正常。

绝大多数工具的默认折叠会破坏代码的可视化结构，使其更难以理解。编辑器中的窗口宽度设置为80个字符。即使该工具将在最后一列中标记字形。一些基于网络的工具可能不会提供动态的自动换行。

有些团队强烈喜欢较长的行长度。对于代码维护完全或主要由一个团队的，可以在这个问题上达成协议，象征性的将行长度从80个字符增加到100个字符（有效地增加最大长度到99个字符）也是可以的，提供注释和文档字符串仍是72个字符。

Python标准库采取保守做法，要求行限制到79个字符（文档字符串/注释到72个字符）。

折叠长行的首选方法是在小括号，中括号，大括号中使用Python隐式换行。长行可以在表达式外面使用小括号来变成多行。连续行使用反斜杠更好。

反斜杠有时可能仍然是合适的。例如，长的多行的with语句不能用隐式续行，可以用反斜杠：  

```python
with open('/path/to/some/file/you/want/to/read') as file_1, \
     open('/path/to/some/file/being/written', 'w') as file_2:
    file_2.write(file_1.read())
```

（为进一步思考With语句的多行缩进，见前面多行if语句的讨论。）

另一个这样的例子是assert语句。

确保适当的连续行缩进

<h3 id='titlebo'>换行应该在二元操作符的前面还是后面？</h3>

过去二十年我们都是推荐放在二元操作符的后面。但是这种做法会以两种方式伤害可读性：多个二元操作符在屏幕上不在一列，另外如果你想知道对一个被操作的对象做了什么操作，需要向上找一行。这导致你的眼睛不得不上下往返很多次才能搞清楚哪个数字是被加的，哪个数字是被减的：

```python
# No: operators sit far away from their operands
income = (gross_wages +
          taxable_interest +
          (dividends - qualified_dividends) -
          ira_deduction -
          student_loan_interest)
```

为了解决可读性问题，数学家和印刷业者通常是在二元操作符之前换行的。Donald Knuth在他的《计算机与排版》系列文章中解释了这个传统规则：“虽然写在一段话中的公式经常在二元操作符的后面换行，但是单独展示的公式通常是在二元操作符的前面换行。”

出于遵循数学传统，所以我们这样写这段代码将更加可读：

```python
# Yes: easy to match operators with operands
income = (gross_wages
          + taxable_interest
          + (dividends - qualified_dividends)
          - ira_deduction
          - student_loan_interest)
```

在Python代码中，二元操作符是可以在前后任意换行的，只要语法上连续。对于新的代码建议采用Knuth的风格（<b>Donald Ervin Knuth</b>，图领奖获得者，著作《计算机程序设计艺术》，此处应该是涉及Literate programming范式）

### 空行

顶级函数和类的定义之间有两行空行。

类内部的函数定义之间有一行空行。

额外的空行用来（谨慎地）分离相关的功能组。相关的行（例如：一组虚拟实现）之间不使用空行。

在函数中谨慎地使用空行来表示逻辑部分。

Python接受control-L（即^L）换页符作为空白符；许多工具把这些字符作为分页符，所以你可以使用它们为文件中的相关部分分页。注意，一些编辑器和基于Web的代码查看器可能不能识别control-L是换页，将显示另外的字形。  

### 源文件编码

Python核心发布中的代码应该始终使用UTF-8（或Python2中用ASCII）。
文件使用ASCII（Python2中）或UTF-8（Python3中）不应有编码声明。

在标准库中，非默认编码仅用于测试目的或注释或文档字符串需要提及包含非ASCII字符的作者名；否则，使用\x，\u，\U，或\N是字符串中包含非ASCII数据的首先方式。

Python3.0及以上版本，为标准库（参见PEP 3131）规定以下策略：Python标准库中的所有标识符必须使用ASCII标识符，在可行的地方使用英文单词（在很多例子中，使用非英文的缩写和专业术语）。另外，字符串和注释必须用ASCII。仅有的例外是（a）测试非ASCII的特点，（b）测试作者名。不是基于拉丁字母表的作者名必须提供一个他们名字的拉丁字母表的音译。

开源项目面向全球，鼓励采用统一策略。  

### 导入

+ 导入通常是单独一行，例如：
  正确的（Yes）：

```python
import os
import sys
```

​	错误的（No）：

```python
import os,sys
```

​	虽然这样也可以：

```python
from subprocess import Popen, PIPE
```

+ 导入常常位于文件顶部，在模块注释和字符串文档之后，在模块的全局变量和常量之前

  导入应该按照以下顺序分组：

  1. 标准库导入
  2. 相关的第三方导入
  3. 特定的本地应用/库导入

  在每个导入组之间放一行空行。

+ 推荐绝对导入，因为它们更易读，并且如果导入系统配置的不正确（例如当包中的一个目录结束于sys.path）它们有更好的表现（至少给出更好的错误信息）

```python
import mypkg.sibling
from mypkg import sibling
from mypkg.sibling import example
```

+ 然而，显式的相对导入替代绝对导入也是可以接受的，特别是处理复杂包布局时，绝对导入过于冗长

```python
from . import sibling
from .sibling import example
```

标准库代码应该避免复杂包布局并使用绝对导入。

隐式的相对导入应该永远不被使用，并且在Python3中已经移除。

> 补充说明：隐式导入是指Python 2在你import一个包时会优先查看项目所在目录下的包，而Python3只会查看标准库或者sys.path（`PYTHONPATH`, `site-packages`等）路径下的包

+ 从一个包含类的模块中导入类时，通常下面这样是好的写法：

```python
from myclass import MyClass
from foo.bar.yourclass import YourClass
```

如果这种写法导致本地名字冲突，那就显式导入：

```python
import myclass
import foo.bar.yourclass
```

然后使用 `myclass.MyClass`和`foo.bar.yourclass.YourClass`

+ 应当避免使用通配符导入（from <模块名> import *），因为它们使哪些名字出现在命名空间变得不清楚，这混淆了读者和许多自动化工具。通配符导入有一种合理的使用情况，重新发布一个内部接口作为一个公共API的一部分（例如，重写一个纯Python实现的接口，该接口定义一个可选的加速器模块并且事先并不知道哪些定义将被重写）

下面涉及的公共和内部接口依然使用上述命名规则

### 模块级别的内置属性

模块级别的内置属性（名字有前后双下划线的），例如__all__, __author__, __version__，应该放置在模块的文档字符串后，任意import语句之前，from __future__导入除外。Python强制要求from __future__导入必须在任何代码之前，只能在模块级文档字符串之后。

```python
"""This is the example module.

This module does stuff.
"""

from __future__ import barry_as_FLUFL

__all__ = ['a', 'b', 'c']
__version__ = '0.1'
__author__ = 'Cardinal Biggles'

import os
import sys
```

## 字符串引号

Python中，单引号字符串和双引号字符串是一样的。本PEP不建议如此。建议选择一条规则并坚持下去。当一个字符串包含单引号字符或双引号字符时，使用另一种字符串引号来避免字符串中使用反斜杠。这提高可读性。

三引号字符串，与PEP 257 文档字符串规范一致总是使用双引号字符。  

> 其实是有区别的，在本人[另一篇博客](_post/2019-06-30-Python知识点总结（包含部分Jupyter Notebook）.md)中也有说明：
> + 单引号`'I\'m "superman"'`，如果字符串中包含单引号`'`，则需要转义符，而双引号`"`不需要
> + 双引号`I'm \"superman\"`，正好相反，包含`"`需要转义符，而单引号`'`不需要
> + 三引号`''' blablabla '''`或者`""" blablabla """`和上述两个区别是支持换行
>
> <font color='red'>因此，如果字符串中有单引号而没双引号，用`'some_str'`更好，反之用双引号；如果有换行用三引号。这样可读性更强</font>

## 表达式和声明中的空格

### 不能忍受的情况

以下情况避免使用多余的空格：

- 紧挨着小括号，中括号或大括号

```python
Yes: spam(ham[1], {eggs: 2})
No:  spam( ham[ 1 ], { eggs: 2 } )
```

+ 在逗号和紧挨着的右括号之间

```python
Yes: foo = (0,)
No:  bar = (0, )
```

+ 紧挨在逗号，分号或冒号前

```python
Yes: if x == 4: print x, y; x, y = y, x
No:  if x == 4 : print x , y ; x , y = y , x
```

+ 在切片中冒号像一个二元操作符，冒号两侧的有相等数量空格（把它看作最低优先级的操作符）。在一个扩展切片中，两个冒号必须有相等数量的空格。例外：当一个切片参数被省略时，该空格被省略。

  正确的（Yes）：

  ```python
  ham[1:9], ham[1:9:3], ham[:9:3], ham[1::3], ham[1:9:]
  ham[lower:upper], ham[lower:upper:], ham[lower::step]
  ham[lower+offset : upper+offset]
  ham[: upper_fn(x) : step_fn(x)], ham[:: step_fn(x)]
  ham[lower + offset : upper + offset]
  ```

  错误的（No）：

  ```python
  ham[lower + offset:upper + offset]
  ham[1: 9], ham[1 :9], ham[1:9 :3]
  ham[lower : : upper]
  ham[ : upper]
  ```

+ 紧接着函数调用参数开始的左括号之前

```python
Yes: dct['key'] = lst[index]
No:  dct ['key'] = lst [index]
```

+ 为了与另外的赋值（或其它）操作符对齐，使用多个空格

正确的（Yes）：

```python
x = 1
y = 2
long_variable = 3
```

错误的（No）：

```python
x             = 1
y             = 2
long_variable = 3
```

### 其他建议

+ 始终避免行尾空白。因为它们通常不可见，容易导致困惑：如果\后面跟了一个空格，它就不是一个有效的续行符了。很多编辑器不保存行尾空白，CPython项目中也设置了commit前检查以拒绝行尾空白的存在。

+ 始终在这些二元操作符的两边放置一个空格：赋值（= ），增强赋值（+= ，-= 等），比较（== ， < ， > ， != ， <> ， <= ， >= ，in ， not in ，is ，is not ），布尔（and ，or ，not ）。

+ <font color='red'>如果使用了不同优先级的操作符，在低优先级操作符周围增加空格（一个或多个）。不要使用多于一个空格，二元运算符两侧空格数量相等。</font>

正确的（Yes）：

```python
i = i + 1
submitted += 1
x = x*2 - 1
hypot2 = x*x + y*y
c = (a+b) * (a-b)
```

错误的（No）：

```python
i=i+1
submitted +=1
x = x * 2 - 1
hypot2 = x * x + y * y
c = (a + b) * (a - b)
```

+ 带注解的函数使用正常的冒号规则，并且在->两侧增加一个空格

正确的（Yes）:

```python
def munge(input: AnyStr): ...
def munge() -> AnyStr: ...
```

错误的（No）:

```python
def munge(input:AnyStr): ...
def munge()->PosInt: ...
```

+ 当=符号用于指示关键字参数或默认参数值时，它周围不要使用空格

正确的（Yes）:

```python
def complex(real, imag=0.0):
    return magic(r=real, i=imag)
```

错误的（No）:

```python
def complex(real, imag = 0.0):
    return magic(r = real, i = imag)
```

然而如果参数既有注释又有默认值，在等号两边增加一个空格（仅在既有注释又有默认值时才加这个空格）

正确的（Yes）:

```python
def munge(sep: AnyStr = None): ...
def munge(input: AnyStr, sep: AnyStr = None, limit=1000): ...
```

错误的（No）:

```python
def munge(input: AnyStr=None): ...
def munge(input: AnyStr, limit = 1000): ...
```

+ 不鼓励使用复合语句（同一行有多条语句）

正确的（Yes）:

```python
if foo == 'blah':
    do_blah_thing()
do_one()
do_two()
do_three()
```

较为不建议的（Rather Not）:

```python
if foo == 'blah': do_blah_thing()
do_one(); do_two(); do_three()
```

+ 尽管有时if/for/while的同一行跟一小段代码，在一个多条子句的语句中不要如此。避免折叠长行！

较为不建议的（Rather Not）:

```python
if foo == 'blah': do_blah_thing()
for x in lst: total += x
while t < 10: t = delay()
```

绝对不行的（Definitely Not）:

```python
if foo == 'blah': do_blah_thing()
else: do_non_blah_thing()

try: something()
finally: cleanup()

do_one(); do_two(); do_three(long, argument,
                             list, like, this)

if foo == 'blah': one(); two(); three()
```

## 什么时候使用尾部逗号？

尾部逗号通常都是可选的，除了一些强制的场景，比如元组在只有一个元素的时候需要一个尾部逗号。为了代码更加清晰，元组只有一个元素时请务必用括号括起来（语法上没有强制要求）：

正确的（Yes）：

```python
FILES = ('setup.cfg',)
```

可行，但是令人困惑的（OK, but confusing）:

```python
FILES = 'setup.cfg',
```

当尾部逗号不是必须时，如果你用了版本控制系统那么它将很有用。当列表元素、参数、导入项未来可能不断增加时，留一个尾部逗号是一个很好的选择。通常的用法是（比如列表）每个元素独占一行，然后尾部都有逗号，在最后一个元素的下一行写闭标签。如果你的数据结构都是写在同一行的，就没有必要保留尾部逗号了。

正确的（Yes）:

```python
FILES = [
    'setup.cfg',
    'tox.ini',
    ]
initialize(FILES,
           error=True,
           )
```

错误的（No）:

```python
FILES = ['setup.cfg', 'tox.ini',]
initialize(FILES, error=True,)
```

## 注释

同代码相矛盾的注释比没有注释更差。当代码修改时，始终优先更新注释！

注释应该是完整的句子。如果注释是一个短语或句子，它的第一个单词的首字母应该大写，除非它是一个以小写字母开头的标识符（不更改标识符的情况下！）。

如果注释很短，末尾可以不加句号。注释块通常由一个或多个段落组成，这些段落由完整的句子组成，并且每个句子都应该以句号结尾。

在句尾的句号后边使用两个空格。

写英语注释时，遵循断词和空格。

非英语国家的Python程序员：请用英语书写注释，除非你120%的确定，所有看你代码的人都和你说一样的语言。

### 注释块

注释块通常适用于一些（或全部）紧跟其后的代码，并且那些代码应使用相同级别的缩进。注释块的每行以一个#和一个空格开始（除非注释里面的文本有缩进）。

注释块内的段落之间由仅包含#的行隔开。  

### 行内注释

谨慎地使用行内注释。

行内注释就是注释和代码在同一行，它与代码之间至少用两个空格隔开。并且它以#和一个空格开始。

如果行内注释指出的是显而易见，那么它就是不必要的。  不要这样做：  

```python
x = x + 1                 # Increment x
```

但有时，这样是有用的：

```python
x = x + 1                 # Compensate for border
```

### 文档字符串

关于良好的文档字符串规范，[PEP 257](<https://www.python.org/dev/peps/pep-0257/>)（有空再填坑吧╮(╯﹏╰）╭）已经很完美的指出

+ 为所有公共模块，函数，类和方法书写文档字符串。对非公开的方法书写文档字符串是没有必要的，但应该写注释描述这个方法是做什么的。这些注释应该写在def行后面。
+ PEP 257规定了好的文档字符串规范。最重要的是，多行文档字符串应当以一行单独的"""结束，例如：

```python
"""Return a foobang

Optional plotz says to frobnicate the bizbaz first.
"""
```

+ 对于一行的文档字符串，应当保证`"""`在同一行

## 命名规范

Python库的命名规范有点儿混乱，所以我们不会将他们变得完全一致——不过，这是目前推荐的命名标准。新模块和包（包括第三方框架）应该按这些标准书写，但对有不同的风格的已有库，保持内部一致性是首选。

### 最高原则

公共部分API的可见名字应当反应接口的作用而非实现

### 描述：命名风格

有很多不同的命名风格。它有助于识别使用了什么样的命名风格，这独立于他们的作用。

下面的命名风格是最常见的：

- b（单个小写字母）
- B（单个大写字母）
- 小写字符串
- 带下划线的小写字符串
- 大写字符串
- 带下划线的大写字符串
- 首字母大写的字符串（或CapWords，或驼峰命名法——因其字母看起来高低不平而得名[3]）。这有时也被称为StudlyCaps。

> 注意：当CapWords中使用缩写，大写所有的缩写字母。因此HTTPServerError优于HttpServerError。

- 混用大小写的字符串（与首字母大写字符串不同的是它以小写字母开头）
- 带下划线的首字母大写字符串（令人厌恶的！）

还有一种风格，使用简短独特的前缀组织相关的名字在一起。Python中很少这样用，提一下是为了文档的完整性。例如，os.stat()函数返回一个元祖，它的元素名字通常类似st_mode，st_size，st_mtime等等这样。（这样做是为了强调与[POSIX系统](<https://baike.baidu.com/item/POSIX>)调用结构体一致，这有助于程序员熟悉这些。）

补充：[编程常用缩写]()

