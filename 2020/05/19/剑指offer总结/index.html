<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="The safest way to try and get what you want, is to try and deserve what you want">
    <meta name="keywords"  content="PF, PF Blog, 炮饭的博客, pfan8, 科技玮, IT, AI, 随笔">
    <meta name="theme-color" content="#000000">
    
    <title>剑指offer总结 - 炮饭的博客 | PF Blog</title>

    <!-- Web App Manifest -->
    <link rel="manifest" href="/pwa/manifest.json">

    <!-- Favicon -->
    <link rel="shortcut icon" href="/img/favicon.ico">

    <!-- Safari Webpage Icon    by-BY -->
    <link rel="apple-touch-icon" href="/img/apple-touch-icon.png">
    
    <!-- Canonical URL -->
    <link rel="canonical" href="http://pfan8.github.io/2020/05/19/%E5%89%91%E6%8C%87offer%E6%80%BB%E7%BB%93/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/hux-blog.min.css">

    <!-- Pygments Github CSS -->
    <link rel="stylesheet" href="/css/syntax.css">

    <!-- Custom Fonts -->
    <!-- <link href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">冬のBlog</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>
                    
                    <li>
                        <a href="/about/">About</a>
                    </li>
                    
                    <li>
                        <a href="/tags/">Tags</a>
                    </li>
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    var __HuxNav__ = {
        close: function(){
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        },
        open: function(){
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }

    // Bind Event
    $toggle.addEventListener('click', function(e){
        if ($navbar.className.indexOf('in') > 0) {
            __HuxNav__.close()
        }else{
            __HuxNav__.open()
        }
    })

    /**
     * Since Fastclick is used to delegate 'touchstart' globally
     * to hack 300ms delay in iOS by performing a fake 'click',
     * Using 'e.stopPropagation' to stop 'touchstart' event from 
     * $toggle/$collapse will break global delegation.
     * 
     * Instead, we use a 'e.target' filter to prevent handler
     * added to document close HuxNav.  
     *
     * Also, we use 'click' instead of 'touchstart' as compromise
     */
    document.addEventListener('click', function(e){
        if(e.target == $toggle) return;
        if(e.target.className == 'icon-bar') return;
        __HuxNav__.close();
    })
</script>


    <!-- Image to hack wechat -->
<!-- <img src="/img/icon_wechat.png" width="0" height="0"> -->
<!-- <img src="/img/post-bg-dsa.jpg" width="0" height="0"> -->

<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        position: relative;
        background-image: url('/img/post-bg-dsa.jpg')
    }

    
</style>
<header class="intro-header" >
    <div class="header-mask"></div>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                        <a class="tag" href="/tags/#算法" title="算法">算法</a>
                        
                    </div>
                    <h1>剑指offer总结</h1>
                    
                    
                    <h2 class="subheading">66题解法思路</h2>
                    
                    <span class="meta">Posted by pfan8 on May 19, 2020</span>
                </div>
            </div>
        </div>
    </div>
    <script type="text/javascript" async
      src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
    <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">
		     <div id="toc"></div>

				<h1 id="1数组二维数组中的查找">1.【数组】二维数组中的查找</h1>

<h2 id="题目描述">题目描述</h2>

<p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>

<h2 id="solution">Solution</h2>

<p>从左下角或者右上角开始查找，沿着一个方向找，因为这里二维矩阵的特性，导致一个元素的左上区域的所有元素必然比它小，同时其右下区域的所有元素必然比它大，因此可以像贪吃蛇那样，交替沿着横轴和纵轴移动，直到找到target或者抵达数组边界返回false</p>

<p><img src="https://thumbsnap.com/i/L7s9zv8e.jpg?0709" alt="" /></p>

<h2 id="code">Code</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># -*- coding:utf-8 -*-
</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="c1"># array 二维列表
</span>
    <span class="k">def</span> <span class="nf">Find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">array</span><span class="p">):</span>
        <span class="c1"># write code here
</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="n">R</span><span class="p">,</span><span class="n">C</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">C</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="n">row</span> <span class="o">=</span> <span class="n">R</span><span class="o">-</span><span class="mi">1</span>
        <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">row</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="n">C</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">target</span> <span class="o">&gt;</span> <span class="n">array</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]:</span>
                <span class="n">col</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">target</span> <span class="o">&lt;</span> <span class="n">array</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]:</span>
                <span class="n">row</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">False</span>
</code></pre></div></div>

<h2 id="复杂度分析">复杂度分析</h2>

<p>假设数组是\(m*n\)的</p>
<ul>
  <li>时间复杂度: \(O(m+n)\)</li>
  <li>空间复杂度：\(O(1)\)</li>
</ul>

<h1 id="2字符串替换空格">2.【字符串】替换空格</h1>

<h2 id="题目描述-1">题目描述</h2>

<p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>

<h2 id="solution-1">Solution</h2>

<ul>
  <li>
    <p>对于Python来说，由于没有char的概念，将字符串转换为list，遍历空格<code class="language-plaintext highlighter-rouge"> </code>替换为<code class="language-plaintext highlighter-rouge">%20</code>即可，然后数组转换为str，用<code class="language-plaintext highlighter-rouge">''.join(s)</code></p>
  </li>
  <li>
    <p>对C++，Java等语言则较为麻烦，则需要考虑char的占位问题，因为<code class="language-plaintext highlighter-rouge">%20</code>比<code class="language-plaintext highlighter-rouge"> </code>占位多2，因此需要记录空格数量，并根据空格数量计算新的数组长度，然后依次拷贝原字符串数组到新字符串数组即可</p>
  </li>
</ul>

<h2 id="code-1">Code</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># -*- coding:utf-8 -*-
</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="c1"># s 源字符串
</span>
    <span class="k">def</span> <span class="nf">replaceSpace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="c1"># write code here
</span>
        <span class="n">s</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s">' '</span><span class="p">:</span>
                <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="s">'%20'</span>
        <span class="k">return</span> <span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="复杂度分析-1">复杂度分析</h2>

<ul>
  <li>时间复杂度：\(O(n)\)</li>
  <li>空间复杂度：\(O(n)\)</li>
</ul>

<h1 id="3链表从头到尾打印链表">3.【链表】从头到尾打印链表</h1>

<h2 id="题目描述-2">题目描述</h2>

<p>输入一个链表，按链表从尾到头的顺序返回一个ArrayList。</p>

<h2 id="solution-2">Solution</h2>

<ul>
  <li>对于Python，不要使用insert插入list，而是使用切片，在append完之后用<code class="language-plaintext highlighter-rouge">[::-1]</code></li>
  <li>对于C++，由于没有内部优化的STL容器，因此每次添加用insert插入头部</li>
</ul>

<h2 id="code-2">Code</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># -*- coding:utf-8 -*-
</span>
<span class="c1"># class ListNode:
</span>
<span class="c1">#     def __init__(self, x):
</span>
<span class="c1">#         self.val = x
</span>
<span class="c1">#         self.next = None
</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="c1"># 返回从尾部到头部的列表值序列，例如[1,2,3]
</span>
    <span class="k">def</span> <span class="nf">printListFromTailToHead</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">listNode</span><span class="p">):</span>
        <span class="c1"># write code here
</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="n">listNode</span><span class="p">:</span>
            <span class="n">res</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">listNode</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
            <span class="n">listNode</span> <span class="o">=</span> <span class="n">listNode</span><span class="p">.</span><span class="nb">next</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<h2 id="复杂度分析-2">复杂度分析</h2>

<ul>
  <li>时间复杂度：\(O(n)\)</li>
  <li>空间复杂度：\(O(n)\)</li>
</ul>

<h1 id="4树重构二叉树">4.【树】重构二叉树</h1>

<h2 id="题目描述-3">题目描述</h2>

<p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>

<h2 id="solution-3">Solution</h2>

<p>本题采用DFS，递归或者用stack非递归，前序序列的第一个元素为root，在中序序列中找到root的位置，则左边是左子树，右边是右子树，从而不断递归构建</p>

<h2 id="code-3">Code</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># -*- coding:utf-8 -*-
</span>
<span class="c1"># class TreeNode:
</span>
<span class="c1">#     def __init__(self, x):
</span>
<span class="c1">#         self.val = x
</span>
<span class="c1">#         self.left = None
</span>
<span class="c1">#         self.right = None
</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="c1"># 返回构造的TreeNode根节点
</span>
    <span class="k">def</span> <span class="nf">reConstructBinaryTree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pre</span><span class="p">,</span> <span class="n">tin</span><span class="p">):</span>
        <span class="c1"># write code here
</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pre</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pre</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">pre</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">pre</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">flag</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">reConstructBinaryTree</span><span class="p">(</span><span class="n">pre</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">tin</span><span class="p">.</span><span class="n">index</span><span class="p">(</span><span class="n">pre</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span><span class="n">tin</span><span class="p">[:</span><span class="n">tin</span><span class="p">.</span><span class="n">index</span><span class="p">(</span><span class="n">pre</span><span class="p">[</span><span class="mi">0</span><span class="p">])])</span>
            <span class="n">flag</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">reConstructBinaryTree</span><span class="p">(</span><span class="n">pre</span><span class="p">[</span><span class="n">tin</span><span class="p">.</span><span class="n">index</span><span class="p">(</span><span class="n">pre</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">+</span><span class="mi">1</span><span class="p">:],</span><span class="n">tin</span><span class="p">[</span><span class="n">tin</span><span class="p">.</span><span class="n">index</span><span class="p">(</span><span class="n">pre</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span> <span class="p">)</span>
        <span class="k">return</span> <span class="n">flag</span>
</code></pre></div></div>

<h2 id="复杂度分析-3">复杂度分析</h2>

<ul>
  <li>时间复杂度：\(O(n)\)</li>
  <li>空间复杂度：\(O(log(n))\)</li>
</ul>

<h1 id="5栈队列用两个栈实现队列">5.【栈、队列】用两个栈实现队列</h1>

<h2 id="题目描述-4">题目描述</h2>

<p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p>

<h2 id="solution-4">Solution</h2>

<p>Queue是FIFO，Stack是FILO，因此要用stack实现queue，需要两个stack，翻转两次即可实现FIFO</p>

<h2 id="code-4">Code</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># -*- coding:utf-8 -*-
</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">stack_push</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">stack_pop</span> <span class="o">=</span> <span class="p">[]</span>
        
    <span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="c1"># write code here
</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">stack_push</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        
    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># return xx
</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">stack_pop</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">stack_pop</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="c1"># 鲁棒性检验：stack_push不能为空，否则pop失败
</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">stack_push</span><span class="p">):</span>
            <span class="k">raise</span> <span class="nb">IndexError</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">stack_push</span><span class="p">):</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">stack_pop</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">stack_push</span><span class="p">.</span><span class="n">pop</span><span class="p">())</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">stack_pop</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
</code></pre></div></div>

<h2 id="复杂度分析-4">复杂度分析</h2>

<ul>
  <li>时间复杂度：
    <ul>
      <li>push,empty：\(O(1)\)</li>
      <li>pop,top：\(O(n)\)</li>
    </ul>
  </li>
  <li>空间复杂度：\(O(n)\)</li>
</ul>

<h1 id="6数组旋转数组的最小数字">6.【数组】旋转数组的最小数字</h1>

<h2 id="题目描述-5">题目描述</h2>

<p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。
输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。
例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。
NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>

<h2 id="solution-5">Solution</h2>

<p>排序的数组只翻转了一次，那么从后往前遍历，一旦前面的数比后面大，就是翻转点</p>

<h2 id="code-5">Code</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># -*- coding:utf-8 -*-
</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">minNumberInRotateArray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rotateArray</span><span class="p">):</span>
        <span class="c1"># write code here
</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rotateArray</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="mi">0</span>
        <span class="n">rotateArray</span> <span class="o">=</span> <span class="n">rotateArray</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">rotateArray</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">rotateArray</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="k">if</span> <span class="n">val</span> <span class="o">&lt;=</span> <span class="n">res</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">val</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">return</span> <span class="n">res</span>
</code></pre></div></div>

<h2 id="复杂度分析-5">复杂度分析</h2>

<ul>
  <li>时间复杂度：\(O(n)\)</li>
  <li>空间复杂度：\(O(1)\)</li>
</ul>

<h1 id="7动态规划斐波那契数列">7.【动态规划】斐波那契数列</h1>

<h2 id="题目描述-6">题目描述</h2>

<p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。n&lt;=39</p>

<h2 id="solution-6">Solution</h2>

<p>memo自底向上，空间效率最高。另外有一个trick：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>声明数组有两个元素，例如 x = [0,1]
如果n&lt;2，则直接返回 x[n]
否则更新 x[0],x[1] = x[1],x[0]+x[1]
</code></pre></div></div>

<h2 id="code-6">Code</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># -*- coding:utf-8 -*-
</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">Fibonacci</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="c1"># write code here
</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
            <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<h2 id="复杂度分析-6">复杂度分析</h2>

<ul>
  <li>时间复杂度：\(O(n)\)</li>
  <li>空间复杂度：\(O(1)\)</li>
</ul>

<h1 id="8动态规划跳台阶">8.【动态规划】跳台阶</h1>

<h2 id="题目描述-7">题目描述</h2>

<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p>

<h2 id="solution-7">Solution</h2>

<p>此题就是斐波那契数列的变形，假设对于第n阶台阶，智能跳1阶或者2阶，那么只能从第n-1阶或者第n-2阶跳上，即有
\(f(n) = f(n-1) + f(n-2)\)
从而变形为斐波那契的题，完全同样的解法，注意初始值(没有0)即可</p>

<h2 id="code-7">Code</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># -*- coding:utf-8 -*-
</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">jumpFloor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number</span><span class="p">):</span>
        <span class="c1"># write code here
</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">number</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="n">number</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">number</span><span class="p">):</span>
            <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<h2 id="复杂度分析-7">复杂度分析</h2>

<ul>
  <li>时间复杂度：\(O(n)\)</li>
  <li>空间复杂度：\(O(1)\)</li>
</ul>

<h1 id="9动态规划变态跳台阶">9.【动态规划】变态跳台阶</h1>

<h2 id="题目描述-8">题目描述</h2>

<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>

<h2 id="solution-8">Solution</h2>

<p>依然是递归变形，但是要复杂一些，考虑n级台阶，假设前n-1阶台阶的次数已知，那么有
\(f(n) = f(n-1) + f(n-2) + ... + f(1)\)
同理，
\(f(n-1) = f(n-2) + f(n-3) + ... + f(1)\)
从而能够推导出通项公式为：
\(f(n) = \begin{cases}
    1 &amp;(n=0) \\
    1 &amp;(n=1) \\
    2*f(n-1) &amp;(n \geq 2)
\end{cases}\)</p>

<p>可以使用上述同样的方法实现，但是有一个更取巧的答案（一行）：</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">return</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">number</span><span class="o">-</span><span class="mi">1</span>
</code></pre></div></div>

<h2 id="code-8">Code</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># -*- coding:utf-8 -*-
</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">jumpFloorII</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number</span><span class="p">):</span>
        <span class="c1"># write code here
</span>
        <span class="k">return</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">number</span><span class="o">-</span><span class="mi">1</span>
</code></pre></div></div>

<h2 id="复杂度分析-8">复杂度分析</h2>

<ul>
  <li>时间复杂度：\(O(n)\)</li>
  <li>空间复杂度：\(O(1)\)</li>
</ul>

<h1 id="10动态规划矩形覆盖">10.【动态规划】矩形覆盖</h1>

<h2 id="题目描述-9">题目描述</h2>

<p>我们可以用2<em>1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2</em>1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p>

<h2 id="solution-9">Solution</h2>

<p>和跳台阶类似，将长度为n的矩形分为n-1和n-2两种情况，从而解法完全相同</p>

<h2 id="code-9">Code</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># -*- coding:utf-8 -*-
</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">rectCover</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number</span><span class="p">):</span>
        <span class="c1"># write code here
</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">number</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">number</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">number</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="n">number</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">number</span><span class="p">):</span>
            <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<h2 id="复杂度分析-9">复杂度分析</h2>

<ul>
  <li>时间复杂度：\(O(n)\)</li>
  <li>空间复杂度：\(O(1)\)</li>
</ul>

<h1 id="11位运算二进制中1的个数">11.【位运算】二进制中1的个数</h1>

<h2 id="题目描述-10">题目描述</h2>

<p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p>

<h2 id="solution-10">Solution</h2>

<p>该题在<a href="https://pfan8.github.io/2019/07/25/%E4%BD%8D%E8%BF%90%E7%AE%97%E6%80%BB%E7%BB%93/#191-number-of-1-bits">位运算总结</a>里有，这里不再赘述，核心是运用<code class="language-plaintext highlighter-rouge">x&amp;(x-1)</code>消去二进制最后一位1</p>

<h2 id="code-10">Code</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># -*- coding:utf-8 -*-
</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">NumberOf1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="c1"># write code here
</span>
        <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">32</span><span class="o">+</span><span class="n">n</span>
        <span class="k">while</span> <span class="n">n</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>
</code></pre></div></div>

<h2 id="复杂度分析-10">复杂度分析</h2>

<ul>
  <li>时间复杂度：\(O(1)\)，看二进制中1的个数，由于题目限制，最多为32，默认常数</li>
  <li>空间复杂度：\(O(1)\)</li>
</ul>

<h1 id="12位运算数值的整数次方">12.【位运算】数值的整数次方</h1>

<h2 id="题目描述-11">题目描述</h2>

<p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。
(即求pow(x,n))</p>

<p>保证base和exponent不同时为0</p>

<h2 id="solution-11">Solution</h2>

<p>同样在<a href="https://pfan8.github.io/2019/07/25/位运算总结/#50-powx-n">位运算总结</a>
核心是对于exponent进行二分/右移，减少乘积次数</p>

<h2 id="code-11">Code</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># -*- coding:utf-8 -*-
</span>
<span class="c1"># x为base，n为exponent
</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">Power</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">x</span>
            <span class="n">n</span> <span class="o">=</span> <span class="o">-</span><span class="n">n</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">n</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">ans</span> <span class="o">*=</span> <span class="n">x</span>
            <span class="n">x</span> <span class="o">*=</span> <span class="n">x</span>
            <span class="n">n</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">ans</span>
</code></pre></div></div>

<h2 id="复杂度分析-11">复杂度分析</h2>

<ul>
  <li>时间复杂度：\(O(logn)\)</li>
  <li>空间复杂度：\(O(1)\)</li>
</ul>

<h1 id="13数组调整数组顺序使奇数位于偶数前面">13.【数组】调整数组顺序使奇数位于偶数前面</h1>

<h2 id="题目描述-12">题目描述</h2>

<p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>

<h2 id="solution-12">Solution</h2>

<ol>
  <li>空间换时间，新建2个数组，偶数放一个数组，奇数放一个数组，最后拼接</li>
  <li>插入排序的思想，遍历一次，两个方向都可以：
    <ol>
      <li>从前往后遍历，则不断往前插入奇数</li>
      <li>从后往前遍历，则不断往后插入偶数</li>
    </ol>
  </li>
</ol>

<h2 id="code-12">Code</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># -*- coding:utf-8 -*-
</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">reOrderArray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array</span><span class="p">):</span>
        <span class="c1"># write code here
</span>
        <span class="n">odd_array</span><span class="p">,</span><span class="n">even_array</span> <span class="o">=</span> <span class="p">[],[]</span>
        <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">array</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">val</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">odd_array</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">even_array</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">even_array</span> <span class="o">+</span> <span class="n">odd_array</span>
</code></pre></div></div>

<h2 id="复杂度分析-12">复杂度分析</h2>

<ol>
  <li>空间换时间
    <ul>
      <li>时间复杂度：\(O(n)\)</li>
      <li>空间复杂度：\(O(n)\)</li>
    </ul>
  </li>
  <li>内部排序
    <ul>
      <li>时间复杂度：\(O(n)\)，最差情况，偶数动n次，整体2n</li>
      <li>空间复杂度：\(O(1)\)</li>
    </ul>
  </li>
</ol>

<h1 id="14链表链表中倒数第k个节点">14.【链表】链表中倒数第k个节点</h1>

<h2 id="题目描述-13">题目描述</h2>

<p>输入一个链表，输出该链表中倒数第k个结点。</p>

<h2 id="solution-13">Solution</h2>

<p>双指针，一个指针先向前走k步，另外一个指针再开始从头开始移动，两个指针一起走，知道前面的指针到头，后面的指针即指向倒数第k个节点</p>

<h2 id="code-13">Code</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># -*- coding:utf-8 -*-
</span>
<span class="c1"># class ListNode:
</span>
<span class="c1">#     def __init__(self, x):
</span>
<span class="c1">#         self.val = x
</span>
<span class="c1">#         self.next = None
</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">FindKthToTail</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="c1"># write code here
</span>
        <span class="n">p_k</span> <span class="o">=</span> <span class="n">head</span>
        <span class="k">while</span> <span class="n">k</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">head</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">None</span>
            <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="p">.</span><span class="nb">next</span>
            <span class="n">k</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">head</span><span class="p">:</span>
            <span class="n">p_k</span> <span class="o">=</span> <span class="n">p_k</span><span class="p">.</span><span class="nb">next</span>
            <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="p">.</span><span class="nb">next</span>
        <span class="k">return</span> <span class="n">p_k</span>
</code></pre></div></div>

<h2 id="复杂度分析-13">复杂度分析</h2>

<ul>
  <li>时间复杂度：\(O(n)\)</li>
  <li>空间复杂度：\(O(1)\)</li>
</ul>

<h1 id="15链表反转链表">15.【链表】反转链表</h1>

<h2 id="题目描述-14">题目描述</h2>

<p>输入一个链表，反转链表后，输出新链表的表头。</p>

<h2 id="solution-14">Solution</h2>

<p>这题算是链表的基本操作题，有一个trick：自行构建空表头，使开头节点指向它，这样可包含空链表的情况</p>

<h2 id="code-14">Code</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># -*- coding:utf-8 -*-
</span>
<span class="c1"># class ListNode:
</span>
<span class="c1">#     def __init__(self, x):
</span>
<span class="c1">#         self.val = x
</span>
<span class="c1">#         self.next = None
</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="c1"># 返回ListNode
</span>
    <span class="k">def</span> <span class="nf">ReverseList</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pHead</span><span class="p">):</span>
        <span class="c1"># write code here
</span>
        <span class="n">emptyHead</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">prevNode</span> <span class="o">=</span> <span class="n">emptyHead</span>
        
        <span class="n">curNode</span> <span class="o">=</span> <span class="n">pHead</span>
        <span class="k">while</span> <span class="n">curNode</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">curNode</span><span class="p">.</span><span class="nb">next</span>
            <span class="n">curNode</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">prevNode</span>
            <span class="n">prevNode</span> <span class="o">=</span> <span class="n">curNode</span>
            <span class="n">curNode</span> <span class="o">=</span> <span class="n">tmp</span>
        <span class="k">return</span> <span class="n">prevNode</span>
</code></pre></div></div>

<h2 id="复杂度分析-14">复杂度分析</h2>

<ul>
  <li>时间复杂度：\(O(n)\)</li>
  <li>空间复杂度：\(O(1)\)</li>
</ul>

<h1 id="16链表合并两个排序的链表">16.【链表】合并两个排序的链表</h1>

<h2 id="题目描述-15">题目描述</h2>

<p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p>

<h2 id="solution-15">Solution</h2>

<p>链表基础操作，判断哪个小插入新表即可</p>

<p>trick：新建空表头ListNode(-1)，可以减少链表头插入的代码</p>

<h2 id="code-15">Code</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># -*- coding:utf-8 -*-
</span>
<span class="c1"># class ListNode:
</span>
<span class="c1">#     def __init__(self, x):
</span>
<span class="c1">#         self.val = x
</span>
<span class="c1">#         self.next = None
</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="c1"># 返回合并后列表
</span>
    <span class="k">def</span> <span class="nf">Merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pHead1</span><span class="p">,</span> <span class="n">pHead2</span><span class="p">):</span>
        <span class="c1"># write code here
</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="n">head</span>
        <span class="k">while</span> <span class="n">pHead1</span> <span class="ow">and</span> <span class="n">pHead2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">pHead1</span><span class="p">.</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">pHead2</span><span class="p">.</span><span class="n">val</span><span class="p">:</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">pHead1</span>
                <span class="n">pHead1</span> <span class="o">=</span> <span class="n">pHead1</span><span class="p">.</span><span class="nb">next</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">pHead2</span>
                <span class="n">pHead2</span> <span class="o">=</span> <span class="n">pHead2</span><span class="p">.</span><span class="nb">next</span>
            <span class="n">cur</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">tmp</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="p">.</span><span class="nb">next</span>
        <span class="k">if</span> <span class="n">pHead1</span><span class="p">:</span>
            <span class="n">cur</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">pHead1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cur</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">pHead2</span>
        <span class="k">return</span> <span class="n">head</span><span class="p">.</span><span class="nb">next</span>
</code></pre></div></div>

<h2 id="复杂度分析-15">复杂度分析</h2>

<ul>
  <li>时间复杂度：\(O(n)\)</li>
  <li>空间复杂度：\(O(1)\)</li>
</ul>

<h1 id="17树树的子结构">17.【树】树的子结构</h1>

<h2 id="题目描述-16">题目描述</h2>

<p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p>

<h2 id="solution-16">Solution</h2>

<p>递归判断，非递归要用stack很麻烦，推荐用递归，逻辑较为清晰</p>

<h2 id="code-16">Code</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># -*- coding:utf-8 -*-
</span>
<span class="c1"># class TreeNode:
</span>
<span class="c1">#     def __init__(self, x):
</span>
<span class="c1">#         self.val = x
</span>
<span class="c1">#         self.left = None
</span>
<span class="c1">#         self.right = None
</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">checkSubtree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pRoot1</span><span class="p">,</span> <span class="n">pRoot2</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">pRoot2</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">pRoot1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="n">pRoot1</span><span class="p">.</span><span class="n">val</span> <span class="o">!=</span> <span class="n">pRoot2</span><span class="p">.</span><span class="n">val</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">checkSubtree</span><span class="p">(</span><span class="n">pRoot1</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">pRoot2</span><span class="p">.</span><span class="n">left</span><span class="p">)</span> \
                <span class="ow">and</span> <span class="bp">self</span><span class="p">.</span><span class="n">checkSubtree</span><span class="p">(</span><span class="n">pRoot1</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">pRoot2</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">HasSubtree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pRoot1</span><span class="p">,</span> <span class="n">pRoot2</span><span class="p">):</span>
        <span class="c1"># write code here
</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">pRoot1</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">pRoot2</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="n">pRoot1</span><span class="p">.</span><span class="n">val</span> <span class="o">==</span> <span class="n">pRoot2</span><span class="p">.</span><span class="n">val</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">checkSubtree</span><span class="p">(</span><span class="n">pRoot1</span><span class="p">,</span> <span class="n">pRoot2</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">HasSubtree</span><span class="p">(</span><span class="n">pRoot1</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">pRoot2</span><span class="p">)</span> \
                <span class="ow">or</span> <span class="bp">self</span><span class="p">.</span><span class="n">HasSubtree</span><span class="p">(</span><span class="n">pRoot1</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">pRoot2</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="复杂度分析-16">复杂度分析</h2>

<ul>
  <li>时间复杂度：\(O(n)\)</li>
  <li>空间复杂度：\(O(logn)\)</li>
</ul>

<h1 id="18树二叉树的镜像">18.【树】二叉树的镜像</h1>

<h2 id="题目描述-17">题目描述</h2>

<p>操作给定的二叉树，将其变换为源二叉树的镜像。
输入描述:</p>

<p>二叉树的镜像定义：源二叉树</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    	    8
    	   /  \
    	  6   10
    	 / \  / \
    	5  7 9 11
    	镜像二叉树
    	    8
    	   /  \
    	  10   6
    	 / \  / \
    	11 9 7  5
</code></pre></div></div>

<h2 id="solution-17">Solution</h2>

<p>同样递归操作，将根节点左右互换，并递归子树同样的操作，直到叶节点即可</p>

<h2 id="code-17">Code</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># -*- coding:utf-8 -*-
</span>
<span class="c1"># class TreeNode:
</span>
<span class="c1">#     def __init__(self, x):
</span>
<span class="c1">#         self.val = x
</span>
<span class="c1">#         self.left = None
</span>
<span class="c1">#         self.right = None
</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="c1"># 返回镜像树的根节点
</span>
    <span class="k">def</span> <span class="nf">Mirror</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
        <span class="c1"># write code here
</span>
        <span class="k">if</span> <span class="n">root</span><span class="p">:</span>
            <span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">root</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">root</span><span class="p">.</span><span class="n">left</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">Mirror</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">Mirror</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="复杂度分析-17">复杂度分析</h2>

<ul>
  <li>时间复杂度：\(O(n)\)</li>
  <li>空间复杂度：\(O(logn)\)</li>
</ul>

<h1 id="19数组顺时针打印矩阵">19.【数组】顺时针打印矩阵</h1>

<h2 id="题目描述-18">题目描述</h2>

<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵：</p>

<blockquote>
  <p>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16</p>
</blockquote>

<p>则依次打印出数字</p>

<blockquote>
  <p>1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p>
</blockquote>

<h2 id="solution-18">Solution</h2>

<p>考验编程功底，双重循环，同时需要：</p>
<ul>
  <li>flag：记录当前方向，或者在一个循环中写好上下左右4次移动</li>
  <li>cnt：记录元素个数，当<code class="language-plaintext highlighter-rouge">cnt==size</code>，说明打印结束</li>
  <li>margin：转了几圈，在遍历的时候需要根据margin判断一个方向的移动在何处停止</li>
</ul>

<h2 id="code-18">Code</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># -*- coding:utf-8 -*-
</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="c1"># matrix类型为二维列表，需要返回列表
</span>
    <span class="k">def</span> <span class="nf">printMatrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">matrix</span><span class="p">):</span>
        <span class="c1"># write code here
</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">row</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">row</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">res</span>
        <span class="n">col</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">col</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">res</span>
        <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">row</span><span class="o">*</span><span class="n">col</span>
        <span class="n">margin</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">cnt</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">:</span>
            <span class="c1"># turn right
</span>
            <span class="k">while</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">col</span><span class="o">-</span><span class="n">margin</span><span class="p">:</span>
                <span class="n">res</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>
                <span class="n">cnt</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">cnt</span> <span class="o">==</span> <span class="n">size</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">res</span>
                <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">j</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c1"># turn down
</span>
            <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">row</span><span class="o">-</span><span class="n">margin</span><span class="p">:</span>
                <span class="n">res</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>
                <span class="n">cnt</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">cnt</span> <span class="o">==</span> <span class="n">size</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">res</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">i</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="n">j</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="c1"># turn left
</span>
            <span class="k">while</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">margin</span><span class="p">:</span>
                <span class="n">res</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>
                <span class="n">cnt</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">cnt</span> <span class="o">==</span> <span class="n">size</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">res</span>
                <span class="n">j</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">i</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="c1"># turn up
</span>
            <span class="n">margin</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">while</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">margin</span><span class="p">:</span>
                <span class="n">res</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>
                <span class="n">cnt</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">cnt</span> <span class="o">==</span> <span class="n">size</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">res</span>
                <span class="n">i</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">res</span>
</code></pre></div></div>

<h2 id="复杂度分析-18">复杂度分析</h2>

<ul>
  <li>时间复杂度：\(O(n)\)</li>
  <li>空间复杂度：\(O(n)\)，存储结果需要的空间</li>
</ul>

<h1 id="20栈包含min函数的栈">20.【栈】包含min函数的栈</h1>

<h2 id="题目描述-19">题目描述</h2>

<p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。</p>

<h2 id="solution-19">Solution</h2>

<p>既然时间复杂度要为\(O(1)\)，那么必然是空间换时间，用两个栈，一个栈放数据，一个栈记录最小值即可</p>

<h2 id="code-19">Code</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># -*- coding:utf-8 -*-
</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">st</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">st_min</span> <span class="o">=</span> <span class="p">[]</span>
        
    <span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="c1"># write code here
</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">st</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">st_min</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span> <span class="ow">or</span> <span class="bp">self</span><span class="p">.</span><span class="n">st_min</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;</span><span class="n">node</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">st_min</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">st_min</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">st_min</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># write code here
</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">st</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="nb">IndexError</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">st</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">st</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">st_mi</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">st_min</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">def</span> <span class="nf">top</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># write code here
</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">st</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="nb">IndexError</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">st</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        
    <span class="k">def</span> <span class="nf">min</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># write code here
</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">st_min</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="nb">IndexError</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">st_min</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<h2 id="复杂度分析-19">复杂度分析</h2>

<ul>
  <li>时间复杂度：\(O(1)\)</li>
  <li>空间复杂度：\(O(n)\)</li>
</ul>

<h1 id="21栈栈的压入弹出序列">21.【栈】栈的压入、弹出序列</h1>

<h2 id="题目描述-20">题目描述</h2>

<p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p>

<h2 id="solution-20">Solution</h2>

<p>用栈模拟该过程，按照压入顺序压入栈，同时判断是否是弹出序列中的值，如果是，弹出栈顶，同时弹出序列向后走一位，如果遍历结束了，弹出序列不为空，说明序列不符</p>

<h2 id="code-20">Code</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># -*- coding:utf-8 -*-
</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">IsPopOrder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pushV</span><span class="p">,</span> <span class="n">popV</span><span class="p">):</span>
        <span class="c1"># write code here
</span>
        <span class="n">st</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">pushV</span><span class="p">):</span>
            <span class="n">st</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">pushV</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">pushV</span> <span class="o">=</span> <span class="n">pushV</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">popV</span><span class="p">)</span> <span class="ow">and</span> <span class="n">st</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="n">popV</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">st</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="n">popV</span> <span class="o">=</span> <span class="n">popV</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">popV</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">return</span> <span class="bp">True</span>
</code></pre></div></div>

<h2 id="复杂度分析-20">复杂度分析</h2>

<ul>
  <li>时间复杂度：\(O(n)\)</li>
  <li>空间复杂度：\(O(n)\)</li>
</ul>

<h1 id="22树从上往下打印二叉树">22.【树】从上往下打印二叉树</h1>

<h2 id="题目描述-21">题目描述</h2>

<p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p>

<h2 id="solution-21">Solution</h2>

<p>按层次遍历，BFS，非递归用queue实现</p>

<h2 id="code-21">Code</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># -*- coding:utf-8 -*-
</span>
<span class="c1"># class TreeNode:
</span>
<span class="c1">#     def __init__(self, x):
</span>
<span class="c1">#         self.val = x
</span>
<span class="c1">#         self.left = None
</span>
<span class="c1">#         self.right = None
</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="c1"># 返回从上到下每个节点值列表，例：[1,2,3]
</span>
    <span class="k">def</span> <span class="nf">PrintFromTopToBottom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
        <span class="c1"># write code here
</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">res</span>
        <span class="n">q</span> <span class="o">=</span> <span class="p">[</span><span class="n">root</span><span class="p">]</span> <span class="c1"># queue
</span>
        <span class="n">lc</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="c1"># layer count
</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">res</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
            <span class="n">lc</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
                <span class="n">q</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
                <span class="n">q</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">lc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">lc</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>
</code></pre></div></div>

<h2 id="复杂度分析-21">复杂度分析</h2>

<ul>
  <li>时间复杂度：\(O(n)\)</li>
  <li>空间复杂度：\(O(n)\)</li>
</ul>

<h1 id="23树二叉搜索树的后序遍历序列">23.【树】二叉搜索树的后序遍历序列</h1>

<h2 id="题目描述-22">题目描述</h2>

<p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p>

<h2 id="solution-22">Solution</h2>

<p>BST的后序序列的合法序列是，对于一个序列S，最后一个元素是x （也就是根），如果去掉最后一个元素的序列为T，那么T满足：T可以分成两段，前一段（左子树）小于x，后一段（右子树）大于x，且这两段（子树）都是合法的后序序列。</p>

<h2 id="code-22">Code</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># -*- coding:utf-8 -*-
</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">VerifySquenceOfBST</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sequence</span><span class="p">):</span>
        <span class="c1"># write code here
</span>
        <span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sequence</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">sequence</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">sequence</span> <span class="o">=</span> <span class="n">sequence</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">split</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">flag</span> <span class="ow">and</span> <span class="n">sequence</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;</span><span class="n">root</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
            <span class="k">if</span> <span class="n">sequence</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&gt;</span><span class="n">root</span><span class="p">:</span>
                <span class="n">flag</span><span class="o">=</span><span class="bp">True</span>
                <span class="n">split</span> <span class="o">=</span> <span class="n">i</span>
        <span class="k">if</span> <span class="n">split</span> <span class="ow">in</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">VerifySquenceOfBST</span><span class="p">(</span><span class="n">sequence</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">VerifySquenceOfBST</span><span class="p">(</span><span class="n">sequence</span><span class="p">[:</span><span class="n">split</span><span class="p">])</span> \
                    <span class="ow">and</span> <span class="bp">self</span><span class="p">.</span><span class="n">VerifySquenceOfBST</span><span class="p">(</span><span class="n">sequence</span><span class="p">[</span><span class="n">split</span><span class="p">:])</span>
</code></pre></div></div>

<h2 id="复杂度分析-22">复杂度分析</h2>

<ul>
  <li>时间复杂度：\(O(n)\)</li>
  <li>空间复杂度：\(O(n)\)</li>
</ul>

<h1 id="24树二叉树中和为某一值的路径">24.【树】二叉树中和为某一值的路径</h1>

<h2 id="题目描述-23">题目描述</h2>

<p>输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)</p>

<h2 id="solution-23">Solution</h2>

<p>相当于是前序遍历的时候累加val，到叶节点判断是否等于期望值（其实不到叶节点也很简单，中途遍历每个节点的时候都判断即可），注意添加路径即可。</p>

<p>P.S. 我一开始以为用非递归的Stack好做一些，结果发现很臃肿，完全不如递归的清晰（捂脸），这里还是贴出递归的版本了</p>

<h2 id="code-23">Code</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># -*- coding:utf-8 -*-
</span>
<span class="c1"># class TreeNode:
</span>
<span class="c1">#     def __init__(self, x):
</span>
<span class="c1">#         self.val = x
</span>
<span class="c1">#         self.left = None
</span>
<span class="c1">#         self.right = None
</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="c1"># 返回二维列表，内部每个列表表示找到的路径
</span>
    <span class="k">def</span> <span class="nf">FindPath</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">expectNumber</span><span class="p">):</span>
        <span class="c1"># write code here
</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span>  <span class="ow">not</span> <span class="n">root</span><span class="p">.</span><span class="n">left</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">root</span><span class="p">.</span><span class="n">right</span> <span class="ow">and</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span> <span class="o">==</span> <span class="n">expectNumber</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[[</span><span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">FindPath</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">,</span><span class="n">expectNumber</span><span class="o">-</span><span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
            <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">FindPath</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">,</span><span class="n">expectNumber</span><span class="o">-</span><span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">left</span><span class="o">+</span><span class="n">right</span><span class="p">:</span>
                <span class="n">tmp</span><span class="p">.</span><span class="n">append</span><span class="p">([</span><span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">]</span><span class="o">+</span><span class="n">item</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tmp</span>
</code></pre></div></div>

<h2 id="复杂度分析-23">复杂度分析</h2>

<ul>
  <li>时间复杂度：\(O(n)\)，二叉树，则每个节点最多走3次，所以是3N</li>
  <li>空间复杂度：\(O(logn)\)</li>
</ul>

<h1 id="25链表复杂链表的复制">25.【链表】复杂链表的复制</h1>

<h2 id="题目描述-24">题目描述</h2>

<p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</p>

<h2 id="solution-24">Solution</h2>

<ol>
  <li>
    <p>字典的方法不详细说了，不过有个trick：用id(node)作为key比直接用node作为key要快一些，也节省空间一些，不过空间的优化可以忽略不计吧。</p>
  </li>
  <li>
    <p>主要说一下In-place的复制方法：</p>
    <ol>
      <li>第一遍复制node的值，将新的node插入每一个原node之后，即假如原链表是
        <blockquote>
          <p>1-&gt;2-&gt;3-&gt;4-&gt;5</p>
        </blockquote>

        <p>经过处理之后成为</p>

        <blockquote>
          <p>1-&gt;1-&gt;2-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5-&gt;5</p>
        </blockquote>
      </li>
      <li>【核心】第二遍复制node的random指针，可以想到，新node的random即为原node的random的next，如此就避免了需要使用dict记录random</li>
      <li>拆分两个链表，返回新链表</li>
    </ol>
  </li>
</ol>

<h2 id="code-24">Code</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># class RandomListNode:
</span>
<span class="c1">#     def __init__(self, x):
</span>
<span class="c1">#         self.label = x
</span>
<span class="c1">#         self.next = None
</span>
<span class="c1">#         self.random = None
</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="c1"># 返回 RandomListNode
</span>
    <span class="k">def</span> <span class="nf">Clone</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pHead</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">pHead</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="n">pHead</span>
        <span class="c1"># 第一次遍历复制值
</span>
        <span class="k">while</span> <span class="n">cur</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">RandomListNode</span><span class="p">(</span><span class="n">cur</span><span class="p">.</span><span class="n">label</span><span class="p">)</span>
            <span class="n">tmp</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">cur</span><span class="p">.</span><span class="nb">next</span>
            <span class="n">cur</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">tmp</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">.</span><span class="nb">next</span>
        <span class="c1"># 第二次遍历复制random指针
</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="n">pHead</span>
        <span class="k">while</span> <span class="n">cur</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">cur</span><span class="p">.</span><span class="n">random</span><span class="p">:</span>
                <span class="n">cur</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="n">random</span> <span class="o">=</span> <span class="n">cur</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nb">next</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="nb">next</span>
        <span class="c1"># 拆分两个链表
</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="n">pHead</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="n">nxt</span> <span class="o">=</span> <span class="n">pHead</span><span class="p">.</span><span class="nb">next</span>
        <span class="k">while</span> <span class="n">cur</span><span class="p">:</span>
            <span class="n">nxt</span> <span class="o">=</span> <span class="n">cur</span><span class="p">.</span><span class="nb">next</span>
            <span class="k">if</span> <span class="n">nxt</span><span class="p">.</span><span class="nb">next</span><span class="p">:</span>
                <span class="n">cur</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">nxt</span><span class="p">.</span><span class="nb">next</span>
                <span class="n">nxt</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">nxt</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="nb">next</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cur</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="p">.</span><span class="nb">next</span>
        <span class="k">return</span> <span class="n">ans</span>
</code></pre></div></div>

<h2 id="复杂度分析-24">复杂度分析</h2>

<ul>
  <li>时间复杂度：\(O(n)\)</li>
  <li>空间复杂度：\(O(n)\)</li>
</ul>

<h1 id="26树链表二叉搜索树与双向链表">26.【树、链表】二叉搜索树与双向链表</h1>

<h2 id="题目描述-25">题目描述</h2>

<p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p>

<h2 id="solution-25">Solution</h2>

<p>相当于中序遍历，但是修改left和right指针的时候需要注意，左子树需要处理之后获取最右侧的节点，同样右子树要获取最左侧的节点，详细见代码</p>

<h2 id="code-25">Code</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># -*- coding:utf-8 -*-
</span>
<span class="c1"># class TreeNode:
</span>
<span class="c1">#     def __init__(self, x):
</span>
<span class="c1">#         self.val = x
</span>
<span class="c1">#         self.left = None
</span>
<span class="c1">#         self.right = None
</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">Convert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pRootOfTree</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">pRootOfTree</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pRootOfTree</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">pRootOfTree</span><span class="p">.</span><span class="n">left</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">pRootOfTree</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pRootOfTree</span>
        <span class="c1"># 处理左子树
</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">Convert</span><span class="p">(</span><span class="n">pRootOfTree</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
        <span class="n">left</span><span class="o">=</span><span class="n">pRootOfTree</span><span class="p">.</span><span class="n">left</span>
 
        <span class="c1"># 连接根与左子树最大结点
</span>
        <span class="k">if</span> <span class="n">left</span><span class="p">:</span>
            <span class="k">while</span><span class="p">(</span><span class="n">left</span><span class="p">.</span><span class="n">right</span><span class="p">):</span>
                <span class="n">left</span><span class="o">=</span><span class="n">left</span><span class="p">.</span><span class="n">right</span>
            <span class="n">pRootOfTree</span><span class="p">.</span><span class="n">left</span><span class="p">,</span><span class="n">left</span><span class="p">.</span><span class="n">right</span><span class="o">=</span><span class="n">left</span><span class="p">,</span><span class="n">pRootOfTree</span>
 
        <span class="c1"># 处理右子树
</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">Convert</span><span class="p">(</span><span class="n">pRootOfTree</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        <span class="n">right</span><span class="o">=</span><span class="n">pRootOfTree</span><span class="p">.</span><span class="n">right</span>
 
        <span class="c1"># 连接根与右子树最小结点
</span>
        <span class="k">if</span> <span class="n">right</span><span class="p">:</span>
            <span class="k">while</span><span class="p">(</span><span class="n">right</span><span class="p">.</span><span class="n">left</span><span class="p">):</span>
                <span class="n">right</span><span class="o">=</span><span class="n">right</span><span class="p">.</span><span class="n">left</span>
            <span class="n">pRootOfTree</span><span class="p">.</span><span class="n">right</span><span class="p">,</span><span class="n">right</span><span class="p">.</span><span class="n">left</span><span class="o">=</span><span class="n">right</span><span class="p">,</span><span class="n">pRootOfTree</span>
             
        <span class="k">while</span><span class="p">(</span><span class="n">pRootOfTree</span><span class="p">.</span><span class="n">left</span><span class="p">):</span>
            <span class="n">pRootOfTree</span><span class="o">=</span><span class="n">pRootOfTree</span><span class="p">.</span><span class="n">left</span>
        <span class="k">return</span> <span class="n">pRootOfTree</span>
</code></pre></div></div>

<h2 id="复杂度分析-25">复杂度分析</h2>

<ul>
  <li>时间复杂度：\(O(n)\)</li>
  <li>空间复杂度：\(O(logn)\)</li>
</ul>

<h1 id="27字符串字符串的排列">27.【字符串】字符串的排列</h1>

<h2 id="题目描述-26">题目描述</h2>

<p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p>

<h2 id="solution-26">Solution</h2>

<p>python有一行的解决方案：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">,</span><span class="n">itertools</span><span class="p">.</span><span class="n">permutations</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">ss</span><span class="p">))))))</span>
</code></pre></div></div>

<p>但是更通用的做法还是用set记录所包含的所有字母，然后做BFS</p>

<h2 id="code-26">Code</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">Permutation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ss</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ss</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
          
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ss</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">ss</span><span class="p">]</span>
          
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span><span class="o">=</span><span class="p">[]</span>
            <span class="n">a</span><span class="o">=</span><span class="n">ss</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">Permutation</span><span class="p">(</span><span class="n">ss</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                    <span class="n">result</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">ii</span><span class="p">[:</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="n">a</span><span class="o">+</span><span class="n">ii</span><span class="p">[</span><span class="n">j</span><span class="p">:])</span>
                 
            <span class="n">result</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
            <span class="n">result</span><span class="p">.</span><span class="n">sort</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">result</span>
</code></pre></div></div>

<h2 id="复杂度分析-26">复杂度分析</h2>

<ul>
  <li>时间复杂度：\(O(n^2)\)</li>
  <li>空间复杂度：\(O(logn)\)</li>
</ul>

<h1 id="28数组数组中出现次数超过一半的数字">28.【数组】数组中出现次数超过一半的数字</h1>

<h2 id="题目描述-27">题目描述</h2>

<p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p>

<h2 id="solution-27">Solution</h2>

<ol>
  <li>通用解法是用dict存储{数字：次数}，当次数＞数组一半长度就返回，否则遍历完返回0</li>
  <li>高级做法是用Boyer-Moore投票算法，具体参考<a href="https://github.com/pfan8/LeetCode/blob/master/%E6%9F%A5%E6%89%BE/169.%20Majority%20Element/%E6%80%BB%E7%BB%93.md">github</a></li>
</ol>

<h2 id="code-27">Code</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">MoreThanHalfNum_Solution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">numbers</span><span class="p">):</span>
        <span class="n">n_cnts</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">line</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">numbers</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">n_cnts</span><span class="p">:</span>
                <span class="n">n_cnts</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">n_cnts</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">n_cnts</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">line</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">n</span>
        <span class="k">return</span> <span class="mi">0</span>
</code></pre></div></div>

<h2 id="复杂度分析-27">复杂度分析</h2>

<ul>
  <li>时间复杂度：\(O(n)\)</li>
  <li>空间复杂度：\(O(n)\)</li>
</ul>

<h1 id="29堆最小的k个数">29.【堆】最小的K个数</h1>

<h2 id="题目描述-28">题目描述</h2>

<p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。</p>

<h2 id="solution-28">Solution</h2>

<p>看排名的代码都是<code class="language-plaintext highlighter-rouge">sorted</code>……，那都没意义了，按题目要求应该用最大堆，并维持堆大小为K。</p>

<p>在Python中heapq默认只支持最小堆，那么将数值取负就相当于构建最大堆了，输出的时候再转换回去</p>

<h2 id="code-28">Code</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">heapq</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">GetLeastNumbers_Solution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tinput</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="n">heap</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tinput</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">k</span><span class="o">==</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">k</span><span class="o">&gt;</span><span class="nb">len</span><span class="p">(</span><span class="n">tinput</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">heap</span>
        <span class="c1"># 取反数值，用最小堆接口实现最大堆
</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">tinput</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">:</span>
                <span class="n">heapq</span><span class="p">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="o">-</span><span class="n">x</span><span class="p">)</span>
            <span class="k">elif</span> <span class="o">-</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">heap</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">heapq</span><span class="p">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span>
                <span class="n">heapq</span><span class="p">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="o">-</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="o">-</span><span class="n">heapq</span><span class="p">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">heap</span><span class="p">))][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<h2 id="复杂度分析-28">复杂度分析</h2>

<ul>
  <li>时间复杂度：\(O(n)\)</li>
  <li>空间复杂度：\(O(n)\)</li>
</ul>

<h1 id="30动态规划连续子数组的最大和">30.【动态规划】连续子数组的最大和</h1>

<h2 id="题目描述-29">题目描述</h2>

<p>HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)</p>

<h2 id="solution-29">Solution</h2>

<p>用动态规划的思想来思考，假设t-1时刻的最大和已知，对于t位置的值来说
\(f(t) = max\{V(t), f(t-1)+V(t)\}\)
可以维护一个dp数组，也可以用一个res保存结果，在每次遍历里比较f(t)的值，比res大就赋值，否则不变即可</p>

<h2 id="code-29">Code</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">FindGreatestSumOfSubArray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array</span><span class="p">):</span>
        <span class="n">sum_lis</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">sum_lis</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">array</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">sum_lis</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">sum_lis</span><span class="o">+</span><span class="n">x</span><span class="p">)</span>
            <span class="n">res</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">sum_lis</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>
</code></pre></div></div>

<h2 id="复杂度分析-29">复杂度分析</h2>

<ul>
  <li>时间复杂度：\(O(n)\)</li>
  <li>空间复杂度：\(O(1)\)</li>
</ul>

<h1 id="31分治整数中1出现的次数从1到n整数中1出现的次数">31.【分治】整数中1出现的次数（从1到n整数中1出现的次数）</h1>

<h2 id="题目描述-30">题目描述</h2>

<p>求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。</p>

<h2 id="solution-30">Solution</h2>

<p>对每一位数单独进行分析，假设<code class="language-plaintext highlighter-rouge">n=12345</code>，取第三位，即<code class="language-plaintext highlighter-rouge">i=3</code>，则：</p>
<ol>
  <li>用<code class="language-plaintext highlighter-rouge">n//3</code>和<code class="language-plaintext highlighter-rouge">n%3</code>分别获取第i位的前缀<code class="language-plaintext highlighter-rouge">pre</code>和后缀<code class="language-plaintext highlighter-rouge">post</code>，以例子解释，<code class="language-plaintext highlighter-rouge">pre</code>代表着有123个100，<code class="language-plaintext highlighter-rouge">post</code>代表100的余数为45</li>
  <li>对第i位的取值分情况讨论:
    <ul>
      <li>如果<code class="language-plaintext highlighter-rouge">n[i]==0</code>：那么第i位的1就出现了\((pre//10)*10^{i-1}\)次，假设<code class="language-plaintext highlighter-rouge">n=12045</code>，则计算得1200</li>
      <li>如果<code class="language-plaintext highlighter-rouge">n[i]==1</code>：除了要加上等于0时的次数，还要再加上<code class="language-plaintext highlighter-rouge">余数+1</code>次，假设<code class="language-plaintext highlighter-rouge">n=12145</code>，则计算得1246</li>
      <li>如果<code class="language-plaintext highlighter-rouge">n[i]&gt;=2</code>：那么第i位的1就出现了\(((pre//10)+1)*10^{i-1}\)次（其实就是0和1加起来），假设<code class="language-plaintext highlighter-rouge">n=12345</code>，则计算得1300</li>
    </ul>
  </li>
</ol>

<p>最后，根据过程写出对应的循环程序即可</p>

<p>trick:由于0和2以上很相似，不用加上余数，0比2以上的情况少\(10^{i-1}\)次，因此可以用<code class="language-plaintext highlighter-rouge">(pre+8)//10</code>来包括两种情况</p>
<h2 id="code-30">Code</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">NumberOf1Between1AndN_Solution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="n">base</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">digit</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">pre</span> <span class="o">=</span> <span class="n">post</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">base</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">:</span>
            <span class="n">pre</span> <span class="o">=</span> <span class="n">n</span> <span class="o">//</span> <span class="n">base</span>
            <span class="n">post</span> <span class="o">=</span> <span class="n">n</span> <span class="o">%</span> <span class="n">base</span>
            <span class="n">digit</span> <span class="o">=</span> <span class="n">pre</span> <span class="o">%</span> <span class="mi">10</span>
            <span class="n">cnt</span> <span class="o">+=</span> <span class="p">(</span><span class="n">pre</span><span class="o">+</span><span class="mi">8</span><span class="p">)</span><span class="o">/</span><span class="mi">10</span> <span class="o">*</span> <span class="n">base</span>
            <span class="k">if</span> <span class="n">digit</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">cnt</span> <span class="o">+=</span> <span class="n">post</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">base</span> <span class="o">*=</span> <span class="mi">10</span>
        <span class="k">return</span> <span class="n">cnt</span>
</code></pre></div></div>

<h2 id="复杂度分析-30">复杂度分析</h2>

<ul>
  <li>时间复杂度：\(O(log_{10}(n))\)</li>
  <li>空间复杂度：\(O(1)\)</li>
</ul>

<h1 id="32排序把数组排成最小的数">32.【排序】把数组排成最小的数</h1>

<h2 id="题目描述-31">题目描述</h2>

<p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p>

<h2 id="solution-31">Solution</h2>

<p>这题的核心是用自定义排序，将str数组按照特定规则排序过后直接拼接输出就可以得到答案，排序需要比较<code class="language-plaintext highlighter-rouge">a+b</code>和<code class="language-plaintext highlighter-rouge">b+a</code>的大小，因为要组成最小的数，就是看拼接<code class="language-plaintext highlighter-rouge">a</code>和<code class="language-plaintext highlighter-rouge">b</code>后谁更小，比如<code class="language-plaintext highlighter-rouge">3</code>和<code class="language-plaintext highlighter-rouge">32</code>，拼接之后就是<code class="language-plaintext highlighter-rouge">332</code>和<code class="language-plaintext highlighter-rouge">323</code>，是<code class="language-plaintext highlighter-rouge">323</code>更小，所以<code class="language-plaintext highlighter-rouge">32</code>要在<code class="language-plaintext highlighter-rouge">3</code>前面，即<code class="language-plaintext highlighter-rouge">32</code>比<code class="language-plaintext highlighter-rouge">3</code>“小”。</p>

<h2 id="code-31">Code</h2>
<p>代码有一些trick：</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">list(map(str, ...))</code></li>
  <li><code class="language-plaintext highlighter-rouge">cmp+lambda</code></li>
  <li><code class="language-plaintext highlighter-rouge">"".join()</code></li>
  <li><code class="language-plaintext highlighter-rouge">lstrip()</code></li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">PrintMinNumber</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">numbers</span><span class="p">):</span>
        <span class="c1"># write code here
</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">numbers</span><span class="p">:</span> 
            <span class="k">return</span> <span class="s">""</span>
        <span class="n">numbers</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">numbers</span><span class="p">))</span>
        <span class="n">numbers</span><span class="p">.</span><span class="n">sort</span><span class="p">(</span><span class="nb">cmp</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">cmp</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="n">x</span><span class="p">))</span>
        <span class="k">return</span> <span class="s">""</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">numbers</span><span class="p">).</span><span class="n">lstrip</span><span class="p">(</span><span class="s">'0'</span><span class="p">)</span> <span class="ow">or</span><span class="s">'0'</span>
</code></pre></div></div>

<h2 id="复杂度分析-31">复杂度分析</h2>

<ul>
  <li>时间复杂度：\(O(nlogn)\)，排序</li>
  <li>空间复杂度：\(O(n)\)</li>
</ul>

<h1 id="33指针丑数">33.【指针】丑数</h1>

<h2 id="题目描述-32">题目描述</h2>

<p>把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p>

<h2 id="solution-32">Solution</h2>

<p>用一个数组存放已知的丑数数组，然后分别用3个指针指向上一次只乘以2、只乘以3和只乘以5的位置，因为丑数只包含因子<code class="language-plaintext highlighter-rouge">2、3、5</code>，所以在对应位置乘以2，3，5，只要比数组最后一位大（已排序），则是新的元素，同时比较2，3，5的新元素，取最小值，就是下一位丑数</p>

<h2 id="code-32">Code</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">GetUglyNumber_Solution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="c1"># write code here
</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">p2</span> <span class="o">=</span> <span class="n">p3</span> <span class="o">=</span> <span class="n">p5</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">index</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
            <span class="n">val2</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">p2</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span>
            <span class="k">while</span> <span class="n">val2</span> <span class="o">&lt;=</span> <span class="n">arr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">p2</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">val2</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">p2</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span>
            <span class="n">val3</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">p3</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span>
            <span class="k">while</span> <span class="n">val3</span> <span class="o">&lt;=</span> <span class="n">arr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">p3</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">val3</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">p3</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span>
            <span class="n">val5</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">p5</span><span class="p">]</span> <span class="o">*</span> <span class="mi">5</span>
            <span class="k">while</span> <span class="n">val5</span> <span class="o">&lt;=</span> <span class="n">arr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">p5</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">val5</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">p5</span><span class="p">]</span> <span class="o">*</span> <span class="mi">5</span>
            <span class="n">new_val</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">val2</span><span class="p">,</span> <span class="n">val3</span><span class="p">,</span> <span class="n">val5</span><span class="p">)</span>
            <span class="n">arr</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_val</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">arr</span><span class="p">[</span><span class="n">index</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<h2 id="复杂度分析-32">复杂度分析</h2>

<ul>
  <li>时间复杂度：\(O(n)\)</li>
  <li>空间复杂度：\(O(n)\)</li>
</ul>

<h1 id="34hash表第一个只出现一次的字符">34.【hash表】第一个只出现一次的字符</h1>

<h2 id="题目描述-33">题目描述</h2>

<p>在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.（从0开始计数）</p>

<h2 id="solution-33">Solution</h2>

<p>因为要获取第一个的位置，所以：</p>
<ul>
  <li>要么字符串遍历2遍</li>
  <li>要么用hash存放次数以及第一次的位置</li>
</ul>

<p>前者时间换空间，后者空间换时间。通常采用后者，下面的代码也是如此</p>

<h2 id="code-33">Code</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">FirstNotRepeatingChar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="c1"># write code here
</span>
        <span class="n">cnts</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">in</span> <span class="n">cnts</span><span class="p">:</span>
                <span class="n">cnts</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span><span class="n">cnts</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">False</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cnts</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">cnts</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">cnts</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">val</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ans</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">ans</span> <span class="o">=</span> <span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ans</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">ans</span>
</code></pre></div></div>

<p>还有个1行的版本</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">FirstNotRepeatingChar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">s</span><span class="p">.</span><span class="n">index</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">c</span><span class="p">:</span><span class="n">s</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">,</span><span class="n">s</span><span class="p">))[</span><span class="mi">0</span><span class="p">])</span> <span class="k">if</span> <span class="n">s</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>
</code></pre></div></div>

<h2 id="复杂度分析-33">复杂度分析</h2>

<ul>
  <li>时间复杂度：\(O(n)\)</li>
  <li>空间复杂度：\(O(n)\)</li>
</ul>

<h1 id="35归并排序数组中的逆序对">35.【归并排序】数组中的逆序对</h1>

<h2 id="题目描述-34">题目描述</h2>

<p>题目描述
在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007
输入描述:
题目保证输入的数组中没有的相同的数字</p>

<p>数据范围：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>对于%50的数据,size&lt;=10^4

对于%75的数据,size&lt;=10^5

对于%100的数据,size&lt;=2*10^5
</code></pre></div></div>

<p>示例1</p>

<p>输入
<code class="language-plaintext highlighter-rouge">1,2,3,4,5,6,7,0</code></p>

<p>输出
<code class="language-plaintext highlighter-rouge">7</code></p>

<h2 id="solution-34">Solution</h2>

<p>用归并排序，并在排序过程中计数逆序对的个数，如此可以将时间复杂度从\(O(n^2)\)降低到\(O(nlogn)\)</p>

<h2 id="code-34">Code</h2>
<p>Python2没有<code class="language-plaintext highlighter-rouge">nonlocal</code>因此用global进行全局计数</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">InversePairs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="k">global</span> <span class="n">count</span>
        <span class="k">def</span> <span class="nf">MergeSort</span><span class="p">(</span><span class="n">lists</span><span class="p">):</span>
            <span class="k">global</span> <span class="n">count</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lists</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">lists</span>
            <span class="n">num</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span><span class="n">lists</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="p">)</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">MergeSort</span><span class="p">(</span><span class="n">lists</span><span class="p">[:</span><span class="n">num</span><span class="p">])</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">MergeSort</span><span class="p">(</span><span class="n">lists</span><span class="p">[</span><span class="n">num</span><span class="p">:])</span>
            <span class="n">r</span><span class="p">,</span> <span class="n">l</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
            <span class="n">result</span><span class="o">=</span><span class="p">[]</span>
            <span class="k">while</span> <span class="n">l</span><span class="o">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="ow">and</span> <span class="n">r</span><span class="o">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="n">right</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">left</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">[</span><span class="n">r</span><span class="p">]:</span>
                    <span class="n">result</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">left</span><span class="p">[</span><span class="n">l</span><span class="p">])</span>
                    <span class="n">l</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">result</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">right</span><span class="p">[</span><span class="n">r</span><span class="p">])</span>
                    <span class="n">r</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">count</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="o">-</span><span class="n">l</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="n">right</span><span class="p">[</span><span class="n">r</span><span class="p">:]</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="n">left</span><span class="p">[</span><span class="n">l</span><span class="p">:]</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="n">MergeSort</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">count</span><span class="o">%</span><span class="mi">1000000007</span>
</code></pre></div></div>

<h2 id="复杂度分析-34">复杂度分析</h2>

<ul>
  <li>时间复杂度：\(O(nlogn)\)</li>
  <li>空间复杂度：\(O(n)\)</li>
</ul>

<h1 id="36双指针两个链表的第一个公共结点">36.【双指针】两个链表的第一个公共结点</h1>

<h2 id="题目描述-35">题目描述</h2>

<p>输入两个链表，找出它们的第一个公共结点。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）</p>

<h2 id="solution-35">Solution</h2>

<p>假设公共部分的节点有n个，链表A的节点有a个，链表B的节点有b个，那么用同向双指针，分别从<code class="language-plaintext highlighter-rouge">链表A-&gt;链表B</code>以及<code class="language-plaintext highlighter-rouge">链表B-&gt;链表A</code>的路径走，那么必然在第二趟的时候在第一个公共节点处碰头。</p>

<h2 id="code-35">Code</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">FindFirstCommonNode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pHead1</span><span class="p">,</span> <span class="n">pHead2</span><span class="p">):</span>
        <span class="n">p1</span><span class="p">,</span><span class="n">p2</span><span class="o">=</span><span class="n">pHead1</span><span class="p">,</span><span class="n">pHead2</span>
        <span class="k">while</span> <span class="n">p1</span><span class="o">!=</span><span class="n">p2</span><span class="p">:</span>
            <span class="n">p1</span> <span class="o">=</span> <span class="n">p1</span><span class="p">.</span><span class="nb">next</span> <span class="k">if</span> <span class="n">p1</span> <span class="k">else</span> <span class="n">pHead2</span>
            <span class="n">p2</span> <span class="o">=</span> <span class="n">p2</span><span class="p">.</span><span class="nb">next</span> <span class="k">if</span> <span class="n">p2</span> <span class="k">else</span> <span class="n">pHead1</span>
        <span class="k">return</span> <span class="n">p1</span>
</code></pre></div></div>

<h2 id="复杂度分析-35">复杂度分析</h2>

<ul>
  <li>时间复杂度：\(O(n+a+b)\)</li>
  <li>空间复杂度：\(O(1)\)</li>
</ul>

<h1 id="37二分查找数字在排序数组中出现的次数">37.【二分查找】数字在排序数组中出现的次数</h1>

<h2 id="题目描述-36">题目描述</h2>

<p>统计一个数字在排序数组中出现的次数。</p>

<h2 id="solution-36">Solution</h2>

<p>二分查找，分别查找起点和终点，和<a href="https://github.com/pfan8/LeetCode/tree/master/%E6%9F%A5%E6%89%BE/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/%5BLeetCode%2034%20M%5D%20Find%20First%20and%20Last%20Position%20of%20Element%20in%20Sorted%20Array">LeetCode 34题</a>相同，可以参考本人对该题的总结</p>

<h2 id="code-36">Code</h2>

<p>python的内置函数，二分查找可以查看上面LeetCode代码</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">GetNumberOfK</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">data</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="复杂度分析-36">复杂度分析</h2>

<ul>
  <li>时间复杂度：\(O(logn)\)</li>
  <li>空间复杂度：\(O(logn)\)，递归开销</li>
</ul>

<h1 id="38递归二叉树的深度">38.【递归】二叉树的深度</h1>

<h2 id="题目描述-37">题目描述</h2>

<p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p>

<h2 id="solution-37">Solution</h2>

<p>递归，求左右子树的深度，取max，再+1</p>

<h2 id="code-37">Code</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">TreeDepth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pRoot</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">pRoot</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">TreeDepth</span><span class="p">(</span><span class="n">pRoot</span><span class="p">.</span><span class="n">left</span><span class="p">),</span><span class="bp">self</span><span class="p">.</span><span class="n">TreeDepth</span><span class="p">(</span><span class="n">pRoot</span><span class="p">.</span><span class="n">right</span><span class="p">))</span><span class="o">+</span><span class="mi">1</span>
</code></pre></div></div>

<h2 id="复杂度分析-37">复杂度分析</h2>

<ul>
  <li>时间复杂度：\(O(logn)\)</li>
  <li>空间复杂度：\(O(logn)\)</li>
</ul>

<h1 id="39递归平衡二叉树">39.【递归】平衡二叉树</h1>

<h2 id="题目描述-38">题目描述</h2>

<p>输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p>

<p>在这里，我们只需要考虑其平衡性，不需要考虑其是不是排序二叉树</p>

<h2 id="solution-38">Solution</h2>

<p>和上题一样，递归求左右子树高度，如果高度差超过1，则不平衡。
注意递归函数要单独写，因为返回int值</p>

<h2 id="code-38">Code</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">Tree_Depth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pRoot</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">pRoot</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">Tree_Depth</span><span class="p">(</span><span class="n">pRoot</span><span class="p">.</span><span class="n">left</span><span class="p">),</span>\
                      <span class="bp">self</span><span class="p">.</span><span class="n">Tree_Depth</span><span class="p">(</span><span class="n">pRoot</span><span class="p">.</span><span class="n">right</span><span class="p">))</span><span class="o">+</span><span class="mi">1</span>
    <span class="k">def</span> <span class="nf">IsBalanced_Solution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pRoot</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">pRoot</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="n">left_depth</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">Tree_Depth</span><span class="p">(</span><span class="n">pRoot</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
        <span class="n">right_depth</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">Tree_Depth</span><span class="p">(</span><span class="n">pRoot</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">left_depth</span> <span class="o">-</span> <span class="n">right_depth</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">return</span> <span class="bp">True</span>
</code></pre></div></div>

<h2 id="复杂度分析-38">复杂度分析</h2>

<ul>
  <li>时间复杂度：\(O(logn)\)</li>
  <li>空间复杂度：\(O(logn)\)</li>
</ul>

<h1 id="40hash位运算数组中只出现一次的数字">40.【hash、位运算】数组中只出现一次的数字</h1>

<h2 id="题目描述-39">题目描述</h2>

<p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p>

<h2 id="solution-39">Solution</h2>

<ol>
  <li>
    <p>针对题目，因为重复的次数只出现2次，因此可以用set（否则用map记录次数），如果元素在set中，则删除，这样遍历完数组后set中只剩下2个单独的数字。</p>
  </li>
  <li>
    <p>位运算：异或，因为只有2次的重复数字异或之后为0，异或的结果就是单独的2个数字异或的结果。我们就取第一个1所在的位数，假设是第3位，接着把原数组分成两组，分组标准是第3位是否为1。如此，相同的数肯定在一个组，因为相同数字所有位都相同，而不同的数，肯定不在一组。然后把这两个组按照最开始的思路，依次异或，剩余的两个结果就是这两个只出现一次的数字。</p>
  </li>
</ol>

<h2 id="code-39">Code</h2>

<p>set</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="c1"># 返回[a,b] 其中ab是出现一次的两个数字
</span>
    <span class="k">def</span> <span class="nf">FindNumsAppearOnce</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array</span><span class="p">):</span>
        <span class="n">filter_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">array</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">filter_set</span><span class="p">:</span>
                <span class="n">filter_set</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">filter_set</span><span class="p">.</span><span class="n">remove</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">filter_set</span><span class="p">)</span>
</code></pre></div></div>

<p>位运算</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">FindNumsAppearOnce</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">array</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="c1"># 对array中的数字进行异或运算
</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">array</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">^=</span> <span class="n">i</span>
        <span class="c1"># 获取tmp中最低位1的位置
</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span>
            <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">array</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">isBit</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
                <span class="n">a</span> <span class="o">^=</span> <span class="n">i</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">b</span> <span class="o">^=</span> <span class="n">i</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span>
 
    <span class="k">def</span> <span class="nf">isBit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
        <span class="s">"""
        判断num的二进制从低到高idx位是不是1
        :param num: 数字
        :param idx: 二进制从低到高位置
        :return: num的idx位是否为1
        """</span>

        <span class="n">num</span> <span class="o">=</span> <span class="n">num</span> <span class="o">&gt;&gt;</span> <span class="n">idx</span>
        <span class="k">return</span> <span class="n">num</span> <span class="o">&amp;</span> <span class="mi">1</span>
</code></pre></div></div>

<h2 id="复杂度分析-39">复杂度分析</h2>

<ul>
  <li>时间复杂度：\(O(n)\)</li>
  <li>空间复杂度：\(O(n)\)</li>
</ul>

<h1 id="41双指针和为s的连续正数序列">41.【双指针】和为S的连续正数序列</h1>

<h2 id="题目描述-40">题目描述</h2>

<p>小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!</p>

<h2 id="solution-40">Solution</h2>

<ol>
  <li>根据数学公式，计算得到</li>
  <li>双指针</li>
</ol>

<h2 id="code-40">Code</h2>
<p>数学计算</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">FindContinuousSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tsum</span><span class="p">):</span>
        <span class="n">res</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">tsum</span><span class="o">//</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">sumRes</span><span class="o">=</span><span class="n">i</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">tsum</span><span class="o">//</span><span class="mi">2</span><span class="o">+</span><span class="mi">2</span><span class="p">):</span>
                <span class="n">sumRes</span><span class="o">+=</span><span class="n">j</span>
                <span class="k">if</span> <span class="n">sumRes</span><span class="o">==</span><span class="n">tsum</span><span class="p">:</span>
                    <span class="n">res</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)))</span>
                    <span class="k">break</span>
                <span class="k">elif</span> <span class="n">sumRes</span><span class="o">&gt;</span><span class="n">tsum</span><span class="p">:</span>
                    <span class="k">break</span>
        <span class="k">return</span> <span class="n">res</span>
</code></pre></div></div>

<p>双指针</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="nc">FindContinuousSequence</span><span class="o">(</span><span class="kt">int</span> <span class="n">sum</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//存放结果</span>
        <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="c1">//两个起点，相当于动态窗口的两边，根据其窗口内的值的和来确定窗口的位置和大小</span>
        <span class="kt">int</span> <span class="n">plow</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span><span class="n">phigh</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">phigh</span> <span class="o">&gt;</span> <span class="n">plow</span><span class="o">){</span>
            <span class="c1">//由于是连续的，差为1的一个序列，那么求和公式是(a0+an)*n/2</span>
            <span class="kt">int</span> <span class="n">cur</span> <span class="o">=</span> <span class="o">(</span><span class="n">phigh</span> <span class="o">+</span> <span class="n">plow</span><span class="o">)</span> <span class="o">*</span> <span class="o">(</span><span class="n">phigh</span> <span class="o">-</span> <span class="n">plow</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
            <span class="c1">//相等，那么就将窗口范围的所有数添加进结果集</span>
            <span class="k">if</span><span class="o">(</span><span class="n">cur</span> <span class="o">==</span> <span class="n">sum</span><span class="o">){</span>
                <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
                <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">plow</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">phigh</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
                    <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
                <span class="o">}</span>
                <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">list</span><span class="o">);</span>
                <span class="n">plow</span><span class="o">++;</span>
            <span class="c1">//如果当前窗口内的值之和小于sum，那么右边窗口右移一下</span>
            <span class="o">}</span><span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">cur</span> <span class="o">&lt;</span> <span class="n">sum</span><span class="o">){</span>
                <span class="n">phigh</span><span class="o">++;</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
            <span class="c1">//如果当前窗口内的值之和大于sum，那么左边窗口右移一下</span>
                <span class="n">plow</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="复杂度分析-40">复杂度分析</h2>

<ul>
  <li>时间复杂度：\(O(n)\)</li>
  <li>空间复杂度：\(O(1)\)</li>
</ul>

<h1 id="42双指针和为s的两个数">42.【双指针】和为S的两个数</h1>

<h2 id="题目描述-41">题目描述</h2>

<p>输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。</p>

<h2 id="solution-41">Solution</h2>

<p>相向双指针，分别从头和尾向中间移动，如果和大于S，则right减1，如果和小于S，则left加1，如果和等于S，直接返回，因为第一次等于S的乘积必然是最小的（left和right差值最大）</p>

<h2 id="code-41">Code</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">FindNumbersWithSum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="n">left</span><span class="p">,</span><span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">+</span> <span class="n">arr</span><span class="p">[</span><span class="n">right</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="n">arr</span><span class="p">[</span><span class="n">left</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">right</span><span class="p">]]</span>
                <span class="k">break</span>
            <span class="k">elif</span> <span class="n">s</span> <span class="o">&gt;</span> <span class="n">target</span><span class="p">:</span>
                <span class="n">right</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">left</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">res</span>
</code></pre></div></div>

<h2 id="复杂度分析-41">复杂度分析</h2>

<ul>
  <li>时间复杂度：\(O(n)\)</li>
  <li>空间复杂度：\(O(1)\)</li>
</ul>

<h1 id="43指针左旋转字符串">43.【指针】左旋转字符串</h1>

<h2 id="题目描述-42">题目描述</h2>

<p>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！</p>

<h2 id="solution-42">Solution</h2>

<p>剑指offer书上写的方法是翻转2次字符串：</p>
<ol>
  <li>翻转全部字符串</li>
  <li>翻转前len(s)-n个字符串</li>
  <li>翻转后面n个字符串
用python的话，切片就好</li>
</ol>

<h2 id="code-42">Code</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">LeftRotateString</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">s</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">s</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">s</span><span class="p">[</span><span class="n">n</span><span class="p">:]</span> <span class="o">+</span> <span class="n">s</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span>
</code></pre></div></div>

<h2 id="复杂度分析-42">复杂度分析</h2>

<ul>
  <li>时间复杂度：\(O(n)\)</li>
  <li>空间复杂度：\(O(1)\)</li>
</ul>

<h1 id="44数组字符串翻转单词顺序列">44.【数组，字符串】翻转单词顺序列</h1>

<h2 id="题目描述-43">题目描述</h2>

<p>牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？</p>

<h2 id="solution-43">Solution</h2>

<p>将s按空格切分成数组，然后用空格倒序拼接数组即可</p>

<h2 id="code-43">Code</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">ReverseSentence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">' '</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s">' '</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">s</span>
</code></pre></div></div>

<h2 id="复杂度分析-43">复杂度分析</h2>

<ul>
  <li>时间复杂度：\(O(n)\)</li>
  <li>空间复杂度：\(O(n)\)</li>
</ul>

<h1 id="45hash表扑克牌顺子">45.【hash表】扑克牌顺子</h1>

<h2 id="题目描述-44">题目描述</h2>

<p>LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。</p>

<h2 id="solution-44">Solution</h2>

<p>需要3个变量：hash表map，2个int（max、min），map记录出现次数，如果非0值出现2次，则不能组成顺子；max和min分别记录非0的最大值和最小值，如果max和min的差值&gt;4，则返回True，否则返回False。</p>

<p>另外，开头要判断数组长度，如果不等于5返回False</p>

<h2 id="code-44">Code</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">IsContinuous</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">numbers</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">5</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="n">m</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">min_card</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">max_card</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">numbers</span><span class="p">:</span>
            <span class="n">m</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">m</span> <span class="k">else</span> <span class="n">m</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span>
            <span class="k">if</span> <span class="n">x</span> <span class="ow">and</span> <span class="n">m</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
            <span class="k">if</span> <span class="n">min_card</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">x</span><span class="p">:</span>
                <span class="n">min_card</span> <span class="o">=</span> <span class="n">x</span>
            <span class="k">elif</span> <span class="n">x</span><span class="p">:</span>
                <span class="n">min_card</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">min_card</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
                
            <span class="k">if</span> <span class="n">max_card</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">x</span><span class="p">:</span>
                <span class="n">max_card</span> <span class="o">=</span> <span class="n">x</span>
            <span class="k">elif</span> <span class="n">x</span><span class="p">:</span>
                <span class="n">max_card</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_card</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">max_card</span> <span class="o">-</span> <span class="n">min_card</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
</code></pre></div></div>

<h2 id="复杂度分析-44">复杂度分析</h2>

<ul>
  <li>时间复杂度：\(O(n)\)</li>
  <li>空间复杂度：\(O(n)\)</li>
</ul>

<h1 id="46递归链表孩子们的游戏圆圈中最后剩下的数">46.【递归、链表】孩子们的游戏(圆圈中最后剩下的数)</h1>

<h2 id="题目描述-45">题目描述</h2>

<p>每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)</p>

<p>如果没有小朋友，请返回-1</p>

<h2 id="solution-45">Solution</h2>

<p>该问题属于<strong>约瑟夫环</strong>问题，按照<a href="https://zh.wikipedia.org/wiki/%E7%BA%A6%E7%91%9F%E5%A4%AB%E6%96%AF%E9%97%AE%E9%A2%98">wiki</a>的说法：</p>
<blockquote>
  <p>比较简单的做法是用循环单链表模拟整个过程，时间复杂度是O(n*m)。如果只是想求得最后剩下的人，则可以用数学推导的方式得出公式。</p>
</blockquote>

<p>显然，该题只要最后的人，所以用数学推导：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>递推公式:

令f[i]表示i个人玩游戏报m退出最后胜利者的编号，最后的结果自然是f[n]。

f[1]=0;

f[i]=(f[i-1]+m)%i;  (i&gt;1)
</code></pre></div></div>

<h2 id="code-45">Code</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">LastRemaining_Solution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
        <span class="c1"># Python的max recursion deep限制，默认1000，按照用例调整可以AC
</span>
        <span class="n">sys</span><span class="p">.</span><span class="n">setrecursionlimit</span><span class="p">(</span><span class="mi">5000</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">LastRemaining_Solution</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span><span class="o">+</span><span class="n">m</span><span class="p">)</span><span class="o">%</span><span class="n">n</span>
</code></pre></div></div>

<p>如果递归有空间限制，那依然只能用链表模拟</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="bp">None</span>
        
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">LastRemaining_Solution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">prev</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">cur</span>
            <span class="n">prev</span> <span class="o">=</span> <span class="n">cur</span>
        <span class="n">prev</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">head</span>
        
        <span class="k">while</span> <span class="n">head</span><span class="p">.</span><span class="nb">next</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">prev</span> <span class="o">=</span> <span class="n">head</span>
                <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="p">.</span><span class="nb">next</span>
            <span class="k">if</span> <span class="n">head</span><span class="p">.</span><span class="nb">next</span> <span class="o">==</span> <span class="n">prev</span><span class="p">:</span>
                <span class="n">prev</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="n">head</span> <span class="o">=</span> <span class="n">prev</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">prev</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">head</span><span class="p">.</span><span class="nb">next</span>
                <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="p">.</span><span class="nb">next</span>
        
        <span class="k">return</span> <span class="n">head</span><span class="p">.</span><span class="n">val</span>
</code></pre></div></div>

<h2 id="复杂度分析-45">复杂度分析</h2>

<ul>
  <li>时间复杂度：\(O(logn)\)</li>
  <li>空间复杂度：\(O(logn)\)</li>
</ul>

<h1 id="47递归求123n">47.【递归】求1+2+3+…+n</h1>

<h2 id="题目描述-46">题目描述</h2>

<p>求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>

<h2 id="solution-46">Solution</h2>

<p>当题目要求不能用条件判断关键字时，通常想到用递归。</p>

<p>该题还要用到<strong>逻辑短路</strong>的技巧，在python中，逻辑短路是a and b，如果a是True则返回a，否则返回b；而在c++中因为赋值语句也有左值（返回ans本身），因此可以直接赋值。</p>

<p>两种语言的具体区别见代码</p>

<h2 id="code-46">Code</h2>
<p>python</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">Sum_Solution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="n">n</span> <span class="o">+=</span> <span class="p">(</span><span class="n">n</span> <span class="ow">and</span> <span class="bp">self</span><span class="p">.</span><span class="n">Sum_Solution</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">n</span>
</code></pre></div></div>

<p>c++</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">Sum_Solution</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
        <span class="n">ans</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ans</span> <span class="o">+=</span> <span class="n">Sum_Solution</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
        <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="复杂度分析-46">复杂度分析</h2>

<ul>
  <li>时间复杂度：\(O(n)\)</li>
  <li>空间复杂度：\(O(n)\)</li>
</ul>

<h1 id="48位运算不用加减乘除做加法">48.【位运算】不用加减乘除做加法</h1>

<h2 id="题目描述-47">题目描述</h2>

<p>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</p>

<h2 id="solution-47">Solution</h2>

<p>不能用四则运算，那明显用位运算：</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>首先看十进制是如何做的： 5+7=12，三步走
第一步：相加各位的值，不算进位，得到2。
第二步：计算进位值，得到10. 如果这一步的进位值为0，那么第一步得到的值就是最终结果。

第三步：重复上述两步，只是相加的值变成上述两步的得到的结果2和10，得到12。

同样我们可以用三步走的方式计算二进制值相加： 5-101，7-111 第一步：相加各位的值，不算进位，得到010，二进制每位相加就相当于各位做异或操作，101^111。

第二步：计算进位值，得到1010，相当于各位做与操作得到101，再向左移一位得到1010，(101&amp;111)&lt;&lt;1。

第三步重复上述两步， 各位相加 010^1010=1000，进位值为100=(010&amp;1010)&lt;&lt;1。
     继续重复上述两步：1000^100 = 1100，进位值为0，跳出循环，1100为最终结果。
</code></pre></div></div>

<h2 id="code-47">Code</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">Add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num1</span><span class="p">,</span> <span class="n">num2</span><span class="p">):</span>
        <span class="k">while</span> <span class="n">num2</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">num1</span><span class="o">^</span><span class="n">num2</span><span class="p">)</span>
            <span class="n">num2</span> <span class="o">=</span> <span class="p">(</span><span class="n">num1</span><span class="o">&amp;</span><span class="n">num2</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">1</span>
            <span class="n">num1</span> <span class="o">=</span> <span class="n">tmp</span>
        <span class="k">return</span> <span class="n">num1</span>
</code></pre></div></div>

<h2 id="复杂度分析-47">复杂度分析</h2>

<ul>
  <li>时间复杂度：\(O(nlogn)\)</li>
  <li>空间复杂度：\(O(n)\)</li>
</ul>

<h1 id="49字符串把字符串转换成整数">49.【字符串】把字符串转换成整数</h1>

<h2 id="题目描述-48">题目描述</h2>

<p>将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0</p>

<h2 id="solution-48">Solution</h2>

<p>没太多说的吧，按照要求循环处理即可，需要注意的是python中不好直接将char转换为int（不用built-in的话），因此要用map来做映射</p>

<h2 id="code-48">Code</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">StrToInt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">s</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="n">is_neg</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">'-'</span><span class="p">:</span>
            <span class="n">is_neg</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">elif</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">'+'</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            
        <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">m</span> <span class="o">=</span> <span class="p">{</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">):</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)}</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">m</span><span class="p">:</span>
                <span class="n">ans</span> <span class="o">=</span> <span class="n">ans</span><span class="o">*</span><span class="mi">10</span> <span class="o">+</span> <span class="n">m</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">break</span>
        <span class="k">return</span> <span class="n">ans</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">is_neg</span> <span class="k">else</span> <span class="o">-</span><span class="n">ans</span>
</code></pre></div></div>

<h2 id="复杂度分析-48">复杂度分析</h2>

<ul>
  <li>时间复杂度：\(O(n)\)</li>
  <li>空间复杂度：\(O(n)\)</li>
</ul>

<h1 id="50hash表数组中重复的数字">50.【hash表】数组中重复的数字</h1>

<h2 id="题目描述-49">题目描述</h2>

<p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p>

<h2 id="solution-49">Solution</h2>

<p>简单的set应用，也没什么说的吧</p>

<h2 id="code-49">Code</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="c1"># 这里要特别注意~找到任意重复的一个值并赋值到duplication[0]
</span>
    <span class="c1"># 函数返回True/False
</span>
    <span class="k">def</span> <span class="nf">duplicate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">numbers</span><span class="p">,</span> <span class="n">duplication</span><span class="p">):</span>
        <span class="n">dup_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">numbers</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">dup_set</span><span class="p">:</span>
                <span class="n">duplication</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
                <span class="k">return</span> <span class="bp">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dup_set</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">False</span>
</code></pre></div></div>

<h2 id="复杂度分析-49">复杂度分析</h2>

<ul>
  <li>时间复杂度：\(O(n)\)</li>
  <li>空间复杂度：\(O(n)\)</li>
</ul>

<h1 id="51动态规划构建乘积数组">51.【动态规划】构建乘积数组</h1>

<h2 id="题目描述-50">题目描述</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>给定一个数组A[0,1,...,n-1],请构建一个数组B[0,1,...,n-1],其中B中的元素
B[i]=A[0]*A[1]*...*A[i-1]*A[i+1]*...*A[n-1]。不能使用除法。（注意：规定
B[0] = A[1] * A[2] * ... * A[n-1]，B[n-1] = A[0] * A[1] * ... * A[n-2];）
</code></pre></div></div>

<h2 id="solution-50">Solution</h2>

<p>最关键的思想是存储已经计算过的中间变量，就是DP的思想。中间变量分为2部分，一部分计算位置i之前的乘积（对应下图下三角部分），另一部分计算位置i之后的乘积（对应下图上三角部分），所以要遍历2次。</p>

<p><img src="https://uploadfiles.nowcoder.com/images/20160829/841505_1472459965615_8640A8F86FB2AB3117629E2456D8C652" alt="" /></p>

<h2 id="code-50">Code</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">multiply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">):</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">B</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">))]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)):</span>
            <span class="n">a</span> <span class="o">*=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span>
            
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">b</span> <span class="o">*=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="n">b</span>
        <span class="k">return</span> <span class="n">B</span>
</code></pre></div></div>

<h2 id="复杂度分析-50">复杂度分析</h2>

<ul>
  <li>时间复杂度：\(O(n)\)</li>
  <li>空间复杂度：\(O(n)\)</li>
</ul>

<h1 id="52回溯正则表达式匹配">52.【回溯】正则表达式匹配</h1>

<h2 id="题目描述-51">题目描述</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>请实现一个函数用来匹配包括'.'和'*'的正则表达式。模式中的字符'.'表示任意一个字符，
而'*'表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。
例如，字符串"aaa"与模式"a.a"和"ab*ac*a"匹配，但是与"aa.a"和"ab*a"均不匹配
</code></pre></div></div>

<h2 id="solution-51">Solution</h2>

<p>字符串匹配时比较复杂的问题（个人觉得），目前来说见过的题就是2种做法：回溯和DP。这个题用回溯的思想来做。主要麻烦在处理<code class="language-plaintext highlighter-rouge">*</code>的时候，因为不知道重复了几次，所以分别尝试不同的分支，一旦成功返回True</p>

<h2 id="code-51">Code</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="c1"># s, pattern都是字符串
</span>
    <span class="k">def</span> <span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">pattern</span><span class="p">):</span>
        <span class="c1"># 如果s与pattern都为空，则True
</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="c1"># 如果s不为空，而pattern为空，则False
</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="c1"># 如果s为空，而pattern不为空，则需要判断
</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># pattern中的第二个字符为*，则pattern后移两位继续比较
</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">pattern</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s">'*'</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">pattern</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
        <span class="c1"># s与pattern都不为空的情况
</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># pattern的第二个字符为*的情况
</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">pattern</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s">'*'</span><span class="p">:</span>
                <span class="c1"># s与pattern的第一个元素不同，则s不变，pattern后移两位，相当于pattern前两位当成空
</span>
                <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">pattern</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">pattern</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s">'.'</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">pattern</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># 如果s[0]与pattern[0]相同，且pattern[1]为*，这个时候有三种情况
</span>
                    <span class="c1"># pattern后移2个，s不变；相当于把pattern前两位当成空，匹配后面的
</span>
                    <span class="c1"># pattern后移2个，s后移1个；相当于pattern前两位与s[0]匹配
</span>
                    <span class="c1"># pattern不变，s后移1个；相当于pattern前两位，与s中的多位进行匹配，因为*可以匹配多位
</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">pattern</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span> <span class="ow">or</span> <span class="bp">self</span><span class="p">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">pattern</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span> <span class="ow">or</span> <span class="bp">self</span><span class="p">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">pattern</span><span class="p">)</span>
            <span class="c1"># pattern第二个字符不为*的情况
</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">pattern</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="n">pattern</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">'.'</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">pattern</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">False</span>

</code></pre></div></div>

<h2 id="复杂度分析-51">复杂度分析</h2>

<ul>
  <li>时间复杂度：\(O(n)\)</li>
  <li>空间复杂度：\(O(n)\)</li>
</ul>

<h1 id="53字符串表示数组的字符串">53.【字符串】表示数组的字符串</h1>

<h2 id="题目描述-52">题目描述</h2>

<p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。</p>

<h2 id="solution-52">Solution</h2>

<p>正常做的话，就是用各种条件分支判断<code class="language-plaintext highlighter-rouge">+|-</code>符号、<code class="language-plaintext highlighter-rouge">.</code>小数点、<code class="language-plaintext highlighter-rouge">e[+-]</code>科学计数法等。
更为实践的做法是用正则，如下方代码</p>

<h2 id="code-52">Code</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">re</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="c1"># s字符串
</span>
    <span class="k">def</span> <span class="nf">isNumeric</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">re</span><span class="p">.</span><span class="n">match</span><span class="p">(</span><span class="s">'^[+-]?[0-9]*(</span><span class="se">\\</span><span class="s">.[0-9]*)?([eE][+-]?[0-9]+)?$'</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="复杂度分析-52">复杂度分析</h2>

<ul>
  <li>时间复杂度：\(O(n)\)</li>
  <li>空间复杂度：\(O(1)\)</li>
</ul>

<h1 id="54hash表字符流中第一个不重复的字符">54.【Hash表】字符流中第一个不重复的字符</h1>

<h2 id="题目描述-53">题目描述</h2>

<p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”</p>

<h2 id="solution-53">Solution</h2>

<p>用map计数，并记录起始位置，需要返回的时候返回1次的最小起始位置对应的char</p>

<p>因为输入的是字符流，所以class内有2个函数，对应的map和一些变量也定义为类成员变量</p>

<h2 id="code-53">Code</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="c1"># 返回对应char
</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">s</span> <span class="o">=</span> <span class="s">''</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">m</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">p</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">fsc</span> <span class="o">=</span> <span class="s">''</span>
        
    <span class="k">def</span> <span class="nf">FirstAppearingOnce</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">while</span> <span class="bp">self</span><span class="p">.</span><span class="n">p</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">s</span><span class="p">):</span>
            <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">s</span><span class="p">[</span><span class="bp">self</span><span class="p">.</span><span class="n">p</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">m</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">m</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">p</span>
                <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">fsc</span> <span class="ow">in</span> <span class="p">(</span><span class="s">'#'</span><span class="p">,</span> <span class="s">''</span><span class="p">):</span>
                    <span class="bp">self</span><span class="p">.</span><span class="n">fsc</span> <span class="o">=</span> <span class="n">c</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">m</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="n">min_pos</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">s</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">fsc</span> <span class="o">==</span> <span class="n">c</span><span class="p">:</span>
                    <span class="bp">self</span><span class="p">.</span><span class="n">fsc</span> <span class="o">=</span> <span class="s">'#'</span>
                    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">m</span><span class="p">:</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">m</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="p">.</span><span class="n">m</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_pos</span><span class="p">:</span>
                            <span class="n">min_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">m</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                            <span class="bp">self</span><span class="p">.</span><span class="n">fsc</span> <span class="o">=</span> <span class="n">key</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">p</span> <span class="o">+=</span> <span class="mi">1</span>
        
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">fsc</span>
        
    <span class="k">def</span> <span class="nf">Insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="c1"># write code here
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">s</span> <span class="o">+=</span> <span class="n">c</span>
</code></pre></div></div>

<h2 id="复杂度分析-53">复杂度分析</h2>

<ul>
  <li>时间复杂度：\(O(n)\)</li>
  <li>空间复杂度：\(O(n)\)</li>
</ul>

<h1 id="55链表双指针链表中环的入口结点">55.【链表、双指针】链表中环的入口结点</h1>

<h2 id="题目描述-54">题目描述</h2>

<p>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。</p>

<h2 id="solution-54">Solution</h2>

<p>设置快慢指针，都从链表头出发，快指针每次走两步，慢指针一次走一步，假如有环，一定相遇于环中某点(结论1)。接着让两个指针分别从相遇点和链表头出发，两者都改为每次走一步，最终相遇于环入口(结论2)。以下是两个结论证明：</p>

<p>两个结论：
1、设置快慢指针，假如有环，他们最后一定相遇。
2、两个指针分别从链表头和相遇点继续出发，每次走一步，最后一定相遇与环入口。</p>

<h2 id="code-54">Code</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">EntryNodeOfLoop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pHead</span><span class="p">):</span>
        <span class="n">fast</span> <span class="o">=</span> <span class="n">pHead</span>
        <span class="n">slow</span> <span class="o">=</span> <span class="n">pHead</span>
        <span class="k">while</span> <span class="n">fast</span> <span class="ow">and</span> <span class="n">fast</span><span class="p">.</span><span class="nb">next</span><span class="p">:</span>
            <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="nb">next</span>
            <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="p">.</span><span class="nb">next</span>
            <span class="k">if</span> <span class="n">fast</span> <span class="o">==</span> <span class="n">slow</span><span class="p">:</span>
                <span class="k">break</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="n">fast</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">fast</span><span class="p">.</span><span class="nb">next</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        
        <span class="n">circle</span> <span class="o">=</span> <span class="n">pHead</span>
        <span class="k">while</span> <span class="n">circle</span> <span class="o">!=</span> <span class="n">fast</span><span class="p">:</span>
            <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="p">.</span><span class="nb">next</span>
            <span class="n">circle</span> <span class="o">=</span> <span class="n">circle</span><span class="p">.</span><span class="nb">next</span>
        <span class="k">return</span> <span class="n">circle</span>
</code></pre></div></div>

<h2 id="复杂度分析-54">复杂度分析</h2>

<ul>
  <li>时间复杂度：\(O(n)\)</li>
  <li>空间复杂度：\(O(1)\)</li>
</ul>

<h1 id="56链表删除链表中重复的结点">56.【链表】删除链表中重复的结点</h1>

<h2 id="题目描述-55">题目描述</h2>

<p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p>

<h2 id="solution-55">Solution</h2>

<p>链表操作，没太多说的，考验编程基本功，注意可以使用自建表头<code class="language-plaintext highlighter-rouge">ListNode(-1)</code>减少一些逻辑判断</p>

<h2 id="code-55">Code</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">deleteDuplication</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pHead</span><span class="p">):</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="n">pHead</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">prev</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">pHead</span>
        <span class="n">pHead</span> <span class="o">=</span> <span class="n">prev</span>
        <span class="n">del_flag</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">while</span> <span class="n">cur</span> <span class="ow">and</span> <span class="n">cur</span><span class="p">.</span><span class="nb">next</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">cur</span><span class="p">.</span><span class="n">val</span> <span class="o">==</span> <span class="n">cur</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="n">val</span><span class="p">:</span>
                <span class="n">cur</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">cur</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="nb">next</span>
                <span class="n">del_flag</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">del_flag</span><span class="p">:</span>
                    <span class="n">prev</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">cur</span><span class="p">.</span><span class="nb">next</span>
                    <span class="n">del_flag</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">prev</span> <span class="o">=</span> <span class="n">cur</span>
                <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="p">.</span><span class="nb">next</span>
        <span class="k">if</span> <span class="n">del_flag</span><span class="p">:</span>
            <span class="n">prev</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">return</span> <span class="n">pHead</span><span class="p">.</span><span class="nb">next</span>
</code></pre></div></div>

<h2 id="复杂度分析-55">复杂度分析</h2>

<ul>
  <li>时间复杂度：\(O(n)\)</li>
  <li>空间复杂度：\(O(1)\)</li>
</ul>

<h1 id="57树二叉树的下一个结点">57.【树】二叉树的下一个结点</h1>

<h2 id="题目描述-56">题目描述</h2>

<p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p>

<h2 id="solution-56">Solution</h2>

<p>分为两种情况：</p>
<ol>
  <li>节点有右子树，那么中序遍历的下一个节点必然在右子树的最左边</li>
  <li>节点没有右子树，则不断查找父节点，直到父节点为空或者该节点不在对应父节点的右子树下</li>
</ol>

<h2 id="code-56">Code</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># class TreeLinkNode:
</span>
<span class="c1">#     def __init__(self, x):
</span>
<span class="c1">#         self.val = x
</span>
<span class="c1">#         self.left = None
</span>
<span class="c1">#         self.right = None
</span>
<span class="c1">#         self.next = None
</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">GetNext</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pNode</span><span class="p">):</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">pNode</span><span class="p">.</span><span class="n">right</span>
        <span class="k">if</span> <span class="n">target</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">target</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
                <span class="n">target</span> <span class="o">=</span> <span class="n">target</span><span class="p">.</span><span class="n">left</span>
            <span class="k">return</span> <span class="n">target</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">target</span> <span class="o">=</span> <span class="n">pNode</span>
            <span class="k">while</span> <span class="n">target</span><span class="p">.</span><span class="nb">next</span> <span class="ow">and</span> <span class="n">target</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="n">right</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
                <span class="n">target</span> <span class="o">=</span> <span class="n">target</span><span class="p">.</span><span class="nb">next</span>
            <span class="k">return</span> <span class="n">target</span><span class="p">.</span><span class="nb">next</span>
</code></pre></div></div>

<h2 id="复杂度分析-56">复杂度分析</h2>

<ul>
  <li>时间复杂度：\(O(logn)\)</li>
  <li>空间复杂度：\(O(1)\)</li>
</ul>

<h1 id="58树递归对称的二叉树">58.【树、递归】对称的二叉树</h1>

<h2 id="题目描述-57">题目描述</h2>

<p>请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p>

<h2 id="solution-57">Solution</h2>

<p>递归判断：</p>
<ol>
  <li>左子树的left == 右子树的right？</li>
  <li>左子树的right == 右子树的left？</li>
</ol>

<h2 id="code-57">Code</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">isSymmetricalCore</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root1</span><span class="p">,</span> <span class="n">root2</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">root2</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root1</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">root2</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="n">root1</span><span class="p">.</span><span class="n">val</span> <span class="o">!=</span> <span class="n">root2</span><span class="p">.</span><span class="n">val</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">isSymmetricalCore</span><span class="p">(</span><span class="n">root1</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">root2</span><span class="p">.</span><span class="n">right</span><span class="p">)</span> \
                <span class="ow">and</span> <span class="bp">self</span><span class="p">.</span><span class="n">isSymmetricalCore</span><span class="p">(</span><span class="n">root1</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">root2</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
                
    <span class="k">def</span> <span class="nf">isSymmetrical</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pRoot</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">pRoot</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">isSymmetricalCore</span><span class="p">(</span><span class="n">pRoot</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">pRoot</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="复杂度分析-57">复杂度分析</h2>

<ul>
  <li>时间复杂度：\(O(logn)\)</li>
  <li>空间复杂度：\(O(logn)\)</li>
</ul>

<h1 id="59树栈按之字形顺序打印二叉树">59.【树、栈】按之字形顺序打印二叉树</h1>

<h2 id="题目描述-58">题目描述</h2>

<p>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p>

<h2 id="solution-58">Solution</h2>

<p>这种反复更改顺序的题，通常做法是用两个stack。不过python有切片<code class="language-plaintext highlighter-rouge">[::-1]</code>，所以也可以用标记flag将节点进行整体翻转</p>

<h2 id="code-58">Code</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">Print</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pRoot</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">pRoot</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="n">nodeStack</span><span class="o">=</span><span class="p">[</span><span class="n">pRoot</span><span class="p">]</span>
        <span class="n">result</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">while</span> <span class="n">nodeStack</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">nextStack</span><span class="o">=</span><span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">nodeStack</span><span class="p">:</span>
                <span class="n">res</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">i</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
                    <span class="n">nextStack</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">i</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
                    <span class="n">nextStack</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
            <span class="n">nodeStack</span><span class="o">=</span><span class="n">nextStack</span>
            <span class="n">result</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
        <span class="n">returnResult</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">result</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span><span class="o">%</span><span class="mi">2</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">returnResult</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">returnResult</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">returnResult</span>
</code></pre></div></div>

<h2 id="复杂度分析-58">复杂度分析</h2>

<ul>
  <li>时间复杂度：\(O(n)\)</li>
  <li>空间复杂度：\(O(n)\)</li>
</ul>

<h1 id="60bfs队列把二叉树打印成多行">60.【BFS，队列】把二叉树打印成多行</h1>

<h2 id="题目描述-59">题目描述</h2>

<p>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p>

<h2 id="solution-59">Solution</h2>

<p>树的按层遍历，BFS，用队列实现</p>

<h2 id="code-59">Code</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="c1"># 返回二维列表[[1,2],[4,5]]
</span>
    <span class="k">def</span> <span class="nf">Print</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pRoot</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">pRoot</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="n">q</span> <span class="o">=</span> <span class="p">[</span><span class="n">pRoot</span><span class="p">]</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[[</span><span class="n">pRoot</span><span class="p">.</span><span class="n">val</span><span class="p">]]</span>
        <span class="n">vec</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="n">q</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
                <span class="n">vec</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
                <span class="n">vec</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">vec</span><span class="p">:</span>
                <span class="n">res</span><span class="p">.</span><span class="n">append</span><span class="p">([</span><span class="n">x</span><span class="p">.</span><span class="n">val</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">vec</span><span class="p">])</span>
                <span class="n">q</span> <span class="o">=</span> <span class="n">vec</span>
                <span class="n">vec</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="n">res</span>
</code></pre></div></div>

<h2 id="复杂度分析-59">复杂度分析</h2>

<ul>
  <li>时间复杂度：\(O(n)\)</li>
  <li>空间复杂度：\(O(n)\)</li>
</ul>

<h1 id="61递归树序列化二叉树">61.【递归、树】序列化二叉树</h1>

<h2 id="题目描述-60">题目描述</h2>

<p>请实现两个函数，分别用来序列化和反序列化二叉树</p>

<p>二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#），以 ！ 表示一个结点值的结束（value!）。</p>

<p>二叉树的反序列化是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。</p>

<p>例如，我们可以把一个只有根节点为1的二叉树序列化为”1,”，然后通过自己的函数来解析回这个二叉树</p>

<h2 id="solution-60">Solution</h2>

<p>树的问题，基本递归都能解决，该题也如此。但是反序列化的时候较为麻烦，用flag计数和标记位置，具体处理见代码</p>

<h2 id="code-60">Code</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">flag</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
         
    <span class="k">def</span> <span class="nf">Serialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">'#,'</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">)</span><span class="o">+</span><span class="s">','</span><span class="o">+</span><span class="bp">self</span><span class="p">.</span><span class="n">Serialize</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span><span class="o">+</span><span class="bp">self</span><span class="p">.</span><span class="n">Serialize</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
         
    <span class="k">def</span> <span class="nf">Deserialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">flag</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">','</span><span class="p">)</span>
         
        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">flag</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="n">root</span> <span class="o">=</span> <span class="bp">None</span>
         
        <span class="k">if</span> <span class="n">l</span><span class="p">[</span><span class="bp">self</span><span class="p">.</span><span class="n">flag</span><span class="p">]</span> <span class="o">!=</span> <span class="s">'#'</span><span class="p">:</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="bp">self</span><span class="p">.</span><span class="n">flag</span><span class="p">]))</span>
            <span class="n">root</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">Deserialize</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="n">root</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">Deserialize</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">root</span>
</code></pre></div></div>

<h2 id="复杂度分析-60">复杂度分析</h2>

<ul>
  <li>时间复杂度：\(O(n)\)</li>
  <li>空间复杂度：\(O(n)\)，主要是递归函数占用的空间。如果树的结构接近线性了，那就是\(O(n)\)，平均应当是\(O(log(n))\)</li>
</ul>

<h1 id="62递归二叉搜索树的第k个结点">62.【递归】二叉搜索树的第k个结点</h1>

<h2 id="题目描述-61">题目描述</h2>

<p>给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8）    中，按结点数值大小顺序第三小结点的值为4。</p>

<h2 id="solution-61">Solution</h2>

<p>树+递归，按照中序遍历的方法做，每次到根节点计数+1，当计数==k时，返回节点</p>

<h2 id="code-61">Code</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="c1"># 返回对应节点TreeNode
</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span>
        
    <span class="k">def</span> <span class="nf">KthNode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pRoot</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">pRoot</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">KthNode</span><span class="p">(</span><span class="n">pRoot</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ans</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ans</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">cnt</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">cnt</span> <span class="o">==</span> <span class="n">k</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pRoot</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">KthNode</span><span class="p">(</span><span class="n">pRoot</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="复杂度分析-61">复杂度分析</h2>

<ul>
  <li>时间复杂度：\(O(n)\)</li>
  <li>空间复杂度：\(O(n)\)</li>
</ul>

<h1 id="63堆数据流中的中位数">63.【堆】数据流中的中位数</h1>

<h2 id="题目描述-62">题目描述</h2>

<p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。</p>

<h2 id="solution-62">Solution</h2>

<p>利用最大堆和最小堆实现，详细过程和更多思路可以看<a href="https://github.com/pfan8/LeetCode/blob/master/%E5%A0%86%E6%A0%88/295.%20Find%20Median%20from%20Data%20Stream/%E6%80%BB%E7%BB%93.md">LeetCode刷题总结</a></p>

<h2 id="code-62">Code</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">minNums</span><span class="o">=</span><span class="p">[]</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">maxNums</span><span class="o">=</span><span class="p">[]</span>

    <span class="k">def</span> <span class="nf">maxHeapInsert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">num</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">maxNums</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
        <span class="n">lens</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">maxNums</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">lens</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">maxNums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="p">.</span><span class="n">maxNums</span><span class="p">[(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]:</span>
                <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">maxNums</span><span class="p">[(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">maxNums</span><span class="p">[(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">maxNums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">maxNums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span>
                <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>
 
    <span class="k">def</span> <span class="nf">maxHeapPop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">maxNums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">maxNums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">maxNums</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">maxNums</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">lens</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">maxNums</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">lens</span><span class="p">:</span>
            <span class="n">nexti</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">nexti</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">lens</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="p">.</span><span class="n">maxNums</span><span class="p">[</span><span class="n">nexti</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="p">.</span><span class="n">maxNums</span><span class="p">[</span><span class="n">nexti</span><span class="p">]:</span>
                <span class="n">nexti</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">maxNums</span><span class="p">[</span><span class="n">nexti</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="p">.</span><span class="n">maxNums</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">maxNums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">maxNums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">maxNums</span><span class="p">[</span><span class="n">nexti</span><span class="p">]</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">maxNums</span><span class="p">[</span><span class="n">nexti</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">nexti</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">return</span>  <span class="n">t</span>
 
    <span class="k">def</span> <span class="nf">minHeapInsert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">num</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">minNums</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
        <span class="n">lens</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">minNums</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">lens</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">minNums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="p">.</span><span class="n">minNums</span><span class="p">[(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]:</span>
                <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">minNums</span><span class="p">[(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">minNums</span><span class="p">[(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">minNums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">minNums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span>
                <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>
 
    <span class="k">def</span> <span class="nf">minHeapPop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">minNums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">minNums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">minNums</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">minNums</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">lens</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">minNums</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">lens</span><span class="p">:</span>
            <span class="n">nexti</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">nexti</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">lens</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="p">.</span><span class="n">minNums</span><span class="p">[</span><span class="n">nexti</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="p">.</span><span class="n">minNums</span><span class="p">[</span><span class="n">nexti</span><span class="p">]:</span>
                <span class="n">nexti</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">minNums</span><span class="p">[</span><span class="n">nexti</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="p">.</span><span class="n">minNums</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">minNums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">minNums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">minNums</span><span class="p">[</span><span class="n">nexti</span><span class="p">]</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">minNums</span><span class="p">[</span><span class="n">nexti</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">nexti</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">return</span> <span class="n">t</span>
 
    <span class="k">def</span> <span class="nf">Insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">minNums</span><span class="p">)</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">maxNums</span><span class="p">))</span><span class="o">&amp;</span><span class="mi">1</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">maxNums</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">num</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="p">.</span><span class="n">maxNums</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">maxHeapInsert</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
                <span class="n">num</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">maxHeapPop</span><span class="p">()</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">minHeapInsert</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">minNums</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">num</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="p">.</span><span class="n">minNums</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">minHeapInsert</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
                <span class="n">num</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">minHeapPop</span><span class="p">()</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">maxHeapInsert</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
 
    <span class="k">def</span> <span class="nf">GetMedian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">n</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">allLen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">minNums</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">maxNums</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">allLen</span> <span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">allLen</span> <span class="o">&amp;</span><span class="mi">1</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">minNums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">maxNums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="p">.</span><span class="n">minNums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mf">0.0</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
</code></pre></div></div>

<h2 id="复杂度分析-62">复杂度分析</h2>

<ul>
  <li>时间复杂度：\(O(1)\)</li>
  <li>空间复杂度：\(O(n)\)</li>
</ul>

<h1 id="64双端队列滑动窗口的最大值">64.【双端队列】滑动窗口的最大值</h1>

<h2 id="题目描述-63">题目描述</h2>

<p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。</p>

<h2 id="solution-63">Solution</h2>

<p>这题是比较经典的题目了，用双端队列实现，LeetCode也有对应的题目，总结<a href="https://github.com/pfan8/LeetCode/blob/master/Conclusion/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.md">在此</a></p>

<h2 id="code-63">Code</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">maxInWindows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
        <span class="n">queue</span><span class="p">,</span><span class="n">res</span><span class="p">,</span><span class="n">i</span> <span class="o">=</span> <span class="p">[],[],</span><span class="mi">0</span>
        <span class="k">while</span> <span class="n">size</span><span class="o">&gt;</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">i</span><span class="o">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">i</span><span class="o">-</span><span class="n">size</span><span class="o">+</span><span class="mi">1</span> <span class="o">&gt;</span> <span class="n">queue</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">queue</span><span class="p">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">num</span><span class="p">[</span><span class="n">queue</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span><span class="o">&lt;</span><span class="n">num</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">queue</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">i</span><span class="o">&gt;=</span><span class="n">size</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">res</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">num</span><span class="p">[</span><span class="n">queue</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">res</span>
</code></pre></div></div>

<h2 id="复杂度分析-63">复杂度分析</h2>

<ul>
  <li>时间复杂度：\(O(n)\)</li>
  <li>空间复杂度：\(O(n)\)</li>
</ul>

<h1 id="65回溯矩阵中的路径">65.【回溯】矩阵中的路径</h1>

<h2 id="题目描述-64">题目描述</h2>

<p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。例如
\(\begin{bmatrix}
a &amp; b &amp; c &amp; e\\
s &amp; f &amp; c &amp; s\\
a &amp; d &amp; e &amp; e
\end{bmatrix}\)
矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</p>

<h2 id="solution-64">Solution</h2>

<p>因为要尝试不同的分支，显然用回溯（Backtracking）</p>

<h2 id="code-64">Code</h2>

<p>trick：走过的地方将<code class="language-plaintext highlighter-rouge">matrix[i][j]</code>置空为’‘，尝试完之后再变回原来的值（这是in-place改动了，如果有不让改动矩阵的要求，就需要自己创建一个矩阵记录状态）</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">hasPath</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">matrix</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">path</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="n">cols</span><span class="o">*</span><span class="n">i</span><span class="p">:</span><span class="n">cols</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="n">cols</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rows</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rows</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cols</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">exist_helper</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
                    <span class="k">return</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">False</span>
    <span class="k">def</span> <span class="nf">exist_helper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="k">return</span> <span class="bp">True</span>
            <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="s">''</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="p">.</span><span class="n">exist_helper</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
                <span class="k">return</span> <span class="bp">True</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="p">.</span><span class="n">exist_helper</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="p">,</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
                <span class="k">return</span> <span class="bp">True</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="p">.</span><span class="n">exist_helper</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
                <span class="k">return</span> <span class="bp">True</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="p">.</span><span class="n">exist_helper</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
                <span class="k">return</span> <span class="bp">True</span>
            <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
</code></pre></div></div>

<h2 id="复杂度分析-64">复杂度分析</h2>

<ul>
  <li>时间复杂度：\(O(n*4^p)\)，忽略边界的情况，每次尝试有4个方向，p长度，以矩阵的每个元素作为起点进行回溯</li>
  <li>空间复杂度：\(O(n)\)，最长递归空间为p，而p不可能大于n</li>
</ul>

<h1 id="66回溯机器人的运动范围">66.【回溯】机器人的运动范围</h1>

<h2 id="题目描述-65">题目描述</h2>

<p>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p>

<h2 id="solution-65">Solution</h2>

<p>可以用染色法的思想，或者数组存储状态+回溯，其实思想是类似的。</p>

<p>另外如果染色法可以，并查集是否可以呢？有时间可以尝试下</p>

<h2 id="code-65">Code</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">movingCount</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">row</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">col</span> <span class="o">=</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span>
        <span class="bp">self</span><span class="p">.</span><span class="nb">dict</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">search</span><span class="p">(</span><span class="n">threshold</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="nb">dict</span><span class="p">)</span>
 
    <span class="k">def</span> <span class="nf">judge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))))</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">))))</span> <span class="o">&lt;=</span> <span class="n">threshold</span>
 
    <span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">.</span><span class="n">judge</span><span class="p">(</span><span class="n">threshold</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="nb">dict</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="p">.</span><span class="nb">dict</span><span class="p">.</span><span class="n">add</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="bp">self</span><span class="p">.</span><span class="n">row</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">search</span><span class="p">(</span><span class="n">threshold</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">j</span> <span class="o">!=</span> <span class="bp">self</span><span class="p">.</span><span class="n">col</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">search</span><span class="p">(</span><span class="n">threshold</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="复杂度分析-65">复杂度分析</h2>

<ul>
  <li>时间复杂度：\(O(n)\)，因为有存储状态，最多所有元素尝试一遍</li>
  <li>空间复杂度：\(O(n)\)</li>
</ul>

<h1 id="67动态规划剪绳子">67.【动态规划】剪绳子</h1>

<h2 id="题目描述-66">题目描述</h2>

<p>给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为k[0],k[1],…,k[m]。请问k[0]xk[1]x…xk[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>

<h2 id="solution-66">Solution</h2>

<ol>
  <li>
    <p>动态规划DP：从1到n，不断计算并存储长度为i时的最大成绩，计算过程是从1到n-1遍历所有数组与i的成绩，即<code class="language-plaintext highlighter-rouge">dp[i]*dp[n-i]</code>，然后取最大值</p>
  </li>
  <li>
    <p>数学总结规律：</p>
    <blockquote>
      <p>题目分析：
 先举几个例子，可以看出规律来。
 4 ： 2<em>2
 5 ： 2</em>3
 6 ： 3<em>3
 7 ： 2</em>2<em>3 或者4</em>3
 8 ： 2<em>3</em>3
 9 ： 3<em>3</em>3
 10：2<em>2</em>3<em>3 或者4</em>3<em>3
 11：2</em>3<em>3</em>3
 12：3<em>3</em>3<em>3
 13：2</em>2<em>3</em>3<em>3 或者4</em>3<em>3</em>3</p>
    </blockquote>

    <p>下面是分析：
 首先判断k[0]到k[m]可能有哪些数字，实际上只可能是2或者3。
 当然也可能有4，但是4=2<em>2，我们就简单些不考虑了。
 5&lt;2</em>3,6&lt;3<em>3,比6更大的数字我们就更不用考虑了，肯定要继续分。
 其次看2和3的数量，2的数量肯定小于3个，为什么呢？因为2</em>2<em>2&lt;3</em>3，那么题目就简单了。
 直接用n除以3，根据得到的余数判断是一个2还是两个2还是没有2就行了。
 由于题目规定m&gt;1，所以2只能是1<em>1，3只能是2</em>1，这两个特殊情况直接返回就行了。
 乘方运算的复杂度为：O(log n)，用动态规划来做会耗时比较多。</p>
  </li>
</ol>

<h2 id="code-66">Code</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">cutRope</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">number</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="n">number</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">):</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">number</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">2</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">subFunction</span><span class="p">(</span><span class="n">number</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">subFunction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number</span><span class="p">):</span>
        <span class="n">tempL</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">number</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">tempL</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">maxV</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">tempL</span><span class="p">[</span><span class="n">number</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">tempL</span><span class="p">[</span><span class="n">number</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">number</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="n">i</span><span class="o">*</span><span class="bp">self</span><span class="p">.</span><span class="n">subFunction</span><span class="p">(</span><span class="n">number</span><span class="o">-</span><span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ans</span><span class="o">&gt;</span><span class="n">maxV</span><span class="p">:</span>
                <span class="n">maxV</span> <span class="o">=</span> <span class="n">ans</span>
                <span class="n">tempL</span><span class="p">[</span><span class="n">number</span><span class="p">]</span> <span class="o">=</span> <span class="n">maxV</span>
        <span class="k">return</span> <span class="n">maxV</span>
</code></pre></div></div>

<h2 id="复杂度分析-66">复杂度分析</h2>

<ul>
  <li>时间复杂度：\(O(n^2)\)</li>
  <li>空间复杂度：\(O(n)\)</li>
</ul>


                <hr style="visibility: hidden;">

                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/2020/05/04/python%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6/" data-toggle="tooltip" data-placement="top" title="Python源码探究">
                        Previous<br>
                        <span>Python源码探究</span>
                        </a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/2020/06/21/github-SSH%E9%85%8D%E7%BD%AE/" data-toggle="tooltip" data-placement="top" title="Github SSH配置">
                        Next<br>
                        <span>Github SSH配置</span>
                        </a>
                    </li>
                    
                </ul>


                <!--Gitalk评论start  -->
                
                <!-- 引入Gitalk评论插件  -->
                <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
                <script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"></script>
                <div id="gitalk-container"></div>
                <!-- 引入一个生产md5的js，用于对id值进行处理，防止其过长 -->
                <!-- Thank DF:https://github.com/NSDingFan/NSDingFan.github.io/issues/3#issuecomment-407496538 -->
                <script src="/js/md5.min.js"></script>
                <script type="text/javascript">
                    var gitalk = new Gitalk({
                    clientID: '7c5c1f80bdd0759e4074',
                    clientSecret: '469697e2f0adba5afda75dc10d3fe5dcab3883de',
                    repo: 'pfan8.github.io',
                    owner: 'pfan8',
                    admin: ['pfan8'],
                    distractionFreeMode: true,
                    id: md5(location.pathname),
                    });
                    gitalk.render('gitalk-container');
                </script>
                
                <!-- Gitalk end -->

                

            </div>  

    <!-- Side Catalog Container -->
        
            <div class="
                col-lg-2 col-lg-offset-0
                visible-lg-block
                sidebar-container
                catalog-container">
                <div class="side-catalog">
                    <hr class="hidden-sm hidden-xs">
                    <h5>
                        <a class="catalog-toggle" href="#">CATALOG</a>
                    </h5>
                    <ul class="catalog-body"></ul>
                </div>
            </div>
        

    <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <hr class="hidden-sm hidden-xs">
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
        				
                            
                				<a href="/tags/#面试" title="面试" rel="2">
                                    面试
                                </a>
                            
        				
                            
                				<a href="/tags/#Machine Learning" title="Machine Learning" rel="2">
                                    Machine Learning
                                </a>
                            
        				
                            
                				<a href="/tags/#工作" title="工作" rel="2">
                                    工作
                                </a>
                            
        				
                            
                				<a href="/tags/#PEP" title="PEP" rel="2">
                                    PEP
                                </a>
                            
        				
                            
                				<a href="/tags/#Python" title="Python" rel="5">
                                    Python
                                </a>
                            
        				
                            
                				<a href="/tags/#规范" title="规范" rel="3">
                                    规范
                                </a>
                            
        				
                            
                				<a href="/tags/#Jupyter Notebook" title="Jupyter Notebook" rel="1">
                                    Jupyter Notebook
                                </a>
                            
        				
                            
                				<a href="/tags/#小象学院" title="小象学院" rel="1">
                                    小象学院
                                </a>
                            
        				
                            
                				<a href="/tags/#NLP" title="NLP" rel="2">
                                    NLP
                                </a>
                            
        				
                            
                				<a href="/tags/#模型" title="模型" rel="1">
                                    模型
                                </a>
                            
        				
                            
                				<a href="/tags/#SOTA" title="SOTA" rel="1">
                                    SOTA
                                </a>
                            
        				
                            
                				<a href="/tags/#IT" title="IT" rel="2">
                                    IT
                                </a>
                            
        				
                            
                				<a href="/tags/#算法" title="算法" rel="11">
                                    算法
                                </a>
                            
        				
                            
                				<a href="/tags/#LSTM" title="LSTM" rel="1">
                                    LSTM
                                </a>
                            
        				
                            
                				<a href="/tags/#深度学习" title="深度学习" rel="1">
                                    深度学习
                                </a>
                            
        				
                            
                				<a href="/tags/#梯度" title="梯度" rel="1">
                                    梯度
                                </a>
                            
        				
                            
                				<a href="/tags/#排序" title="排序" rel="1">
                                    排序
                                </a>
                            
        				
                            
                				<a href="/tags/#总结" title="总结" rel="3">
                                    总结
                                </a>
                            
        				
                            
                				<a href="/tags/#贪心" title="贪心" rel="1">
                                    贪心
                                </a>
                            
        				
                            
                				<a href="/tags/#动态规划" title="动态规划" rel="2">
                                    动态规划
                                </a>
                            
        				
                            
                				<a href="/tags/#数据结构" title="数据结构" rel="1">
                                    数据结构
                                </a>
                            
        				
                            
                				<a href="/tags/#堆" title="堆" rel="1">
                                    堆
                                </a>
                            
        				
                            
                				<a href="/tags/#栈" title="栈" rel="1">
                                    栈
                                </a>
                            
        				
                            
                				<a href="/tags/#背包问题" title="背包问题" rel="1">
                                    背包问题
                                </a>
                            
        				
                            
                				<a href="/tags/#C++" title="C++" rel="1">
                                    C++
                                </a>
                            
        				
                            
                				<a href="/tags/#STL" title="STL" rel="1">
                                    STL
                                </a>
                            
        				
                            
                				<a href="/tags/#位运算" title="位运算" rel="2">
                                    位运算
                                </a>
                            
        				
                            
                				<a href="/tags/#double pointer" title="double pointer" rel="1">
                                    double pointer
                                </a>
                            
        				
                            
                				<a href="/tags/#快慢指针" title="快慢指针" rel="1">
                                    快慢指针
                                </a>
                            
        				
                            
                				<a href="/tags/#链表" title="链表" rel="1">
                                    链表
                                </a>
                            
        				
                            
                				<a href="/tags/#cpython" title="cpython" rel="1">
                                    cpython
                                </a>
                            
        				
                            
                				<a href="/tags/#字符串匹配" title="字符串匹配" rel="1">
                                    字符串匹配
                                </a>
                            
        				
                            
                				<a href="/tags/#github" title="github" rel="1">
                                    github
                                </a>
                            
        				
                            
                				<a href="/tags/#ssh" title="ssh" rel="1">
                                    ssh
                                </a>
                            
        				
                            
                				<a href="/tags/#安全" title="安全" rel="1">
                                    安全
                                </a>
                            
        				
                            
                				<a href="/tags/#git" title="git" rel="1">
                                    git
                                </a>
                            
        				
                            
                				<a href="/tags/#css" title="css" rel="1">
                                    css
                                </a>
                            
        				
                            
                				<a href="/tags/#layout" title="layout" rel="1">
                                    layout
                                </a>
                            
        				
                            
                				<a href="/tags/#responsive" title="responsive" rel="1">
                                    responsive
                                </a>
                            
        				
                            
                				<a href="/tags/#life" title="life" rel="1">
                                    life
                                </a>
                            
        				
                            
                				<a href="/tags/#film" title="film" rel="1">
                                    film
                                </a>
                            
        				
                            
                				<a href="/tags/#javascript" title="javascript" rel="4">
                                    javascript
                                </a>
                            
        				
                            
                				<a href="/tags/#functional programming" title="functional programming" rel="1">
                                    functional programming
                                </a>
                            
        				
                            
                				<a href="/tags/#nodejs" title="nodejs" rel="1">
                                    nodejs
                                </a>
                            
        				
                            
                				<a href="/tags/#工具" title="工具" rel="1">
                                    工具
                                </a>
                            
        				
                            
                				<a href="/tags/#图论" title="图论" rel="1">
                                    图论
                                </a>
                            
        				
                            
                				<a href="/tags/#最小生成树" title="最小生成树" rel="1">
                                    最小生成树
                                </a>
                            
        				
                            
                				<a href="/tags/#并查集" title="并查集" rel="1">
                                    并查集
                                </a>
                            
        				
                            
                				<a href="/tags/#oauth" title="oauth" rel="1">
                                    oauth
                                </a>
                            
        				
                            
                				<a href="/tags/#node" title="node" rel="1">
                                    node
                                </a>
                            
        				
                            
                				<a href="/tags/#express" title="express" rel="1">
                                    express
                                </a>
                            
        				
                            
                				<a href="/tags/#cookie" title="cookie" rel="1">
                                    cookie
                                </a>
                            
        				
        			</div>
                </section>
                

                <!-- Friends Blog -->
                
                <hr>
                <h5>FRIENDS</h5>
                <ul class="list-inline">
                    
                        <li><a href="http://zhengwuyang.com">WY</a></li>
                    
                        <li><a href="http://www.jianshu.com/u/e71990ada2fd">简书·BY</a></li>
                    
                        <li><a href="https://apple.com">Apple</a></li>
                    
                        <li><a href="https://developer.apple.com/">Apple Developer</a></li>
                    
                </ul>
                
            </div>
        </div>
    </div>
</article>






<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("//cdnjs.cloudflare.com/ajax/libs/anchor-js/1.1.1/anchor.min.js",function(){
        // BY Fix:去除标题前的‘#’ issues:<https://github.com/qiubaiying/qiubaiying.github.io/issues/137>
        // anchors.options = {
        //   visible: 'always',
        //   placement: 'right',
        //   icon: '#'
        // };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    
                    <!-- add jianshu add target = "_blank" to <a> by BY -->
                    
                            <li>
                                <a target="_blank" href="https://www.jianshu.com/u/e71990ada2fd">
                                    <span class="fa-stack fa-lg">
                                        <i class="fa fa-circle fa-stack-2x"></i>
                                        <i class="fa  fa-stack-1x fa-inverse">简</i>
                                    </span>
                                </a>
                            </li>
                    
                    

                    <!-- add Weibo, Zhihu by Hux, add target = "_blank" to <a> by Hux -->
                    
                    <li>
                        <a target="_blank" href="https://www.zhihu.com/people/pfan8">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa  fa-stack-1x fa-inverse">知</i>
                            </span>
                        </a>
                    </li>
                    
                    


                    
                    <li>
                        <a target="_blank" href="https://www.facebook.com/pfan8">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-facebook fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li>
                        <a target="_blank" href="https://github.com/pfan8">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; 冬のBlog 2021
                    <br>
                    Theme on <a href="https://github.com/pfan8/pfan8.github.io.git">GitHub</a> |
                    <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="100px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=pfan8&repo=pfan8.github.io&type=star&count=true" >
                    </iframe>
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js "></script>

<!-- TOC -->
<script src="/js/toc.js "></script>

<!--start TOC -->
<script type="text/javascript">
$(document).ready(function() {
    $('#toc').toc();
}); 
</script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js "></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js "></script>

<!-- Service Worker -->

<script type="text/javascript">
    if(navigator.serviceWorker){
        // For security reasons, a service worker can only control the pages that are in the same directory level or below it. That's why we put sw.js at ROOT level.
        navigator.serviceWorker
            .register('/sw.js')
            .then((registration) => {console.log('Service Worker Registered. ', registration)})
            .catch((error) => {console.log('ServiceWorker registration failed: ', error)})
    }
</script>



<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/ 
     - https://github.com/jneen/rouge/wiki/list-of-supported-languages-and-lexers   
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async('/js/jquery.tagcloud.js',function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->

<script>
    // dynamic User by Hux
    var _gaId = 'UA-90855596-1';
    var _gaDomain = 'qiubaiying.top';

    // Originial
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', _gaId, _gaDomain);
    ga('send', 'pageview');
</script>



<!-- Baidu Tongji -->

<script>
    // dynamic User by Hux
    var _baId = 'b50bf2b12b5338a1845e33832976fd68';

    // Originial
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?" + _baId;
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
</script>




<!-- Side Catalog -->

<script type="text/javascript">
    function generateCatalog (selector) {
        var P = $('div.post-container'),a,n,t,l,i,c;
        a = P.find('h1,h2,h3,h4,h5,h6');
        a.each(function () {
            n = $(this).prop('tagName').toLowerCase();
            i = "#"+$(this).prop('id');
            t = $(this).text();
            c = $('<a href="'+i+'" rel="nofollow">'+t+'</a>');
            l = $('<li class="'+n+'_nav"></li>').append(c);
            $(selector).append(l);
        });
        return true;    
    }

    generateCatalog(".catalog-body");

    // toggle side catalog
    $(".catalog-toggle").click((function(e){
        e.preventDefault();
        $('.side-catalog').toggleClass("fold")
    }))

    /*
     * Doc: https://github.com/davist11/jQuery-One-Page-Nav
     * Fork by Hux to support padding
     */
    async("/js/jquery.nav.js", function () {
        $('.catalog-body').onePageNav({
            currentClass: "active",
            changeHash: !1,
            easing: "swing",
            filter: "",
            scrollSpeed: 700,
            scrollOffset: 0,
            scrollThreshold: .2,
            begin: null,
            end: null,
            scrollChange: null,
            padding: 80
        });
    });
</script>





<!-- Image to hack wechat -->
<img src="/img/apple-touch-icon.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
